const char common_fxc_h[] = "//========= Copyright Valve Corporation, All rights reserved. ============//\n""\n""//\n""\n""// Purpose: \n""\n""//\n""\n""// $NoKeywords: $\n""\n""//\n""\n""//=============================================================================//\n""\n""#ifndef COMMON_FXC_H_\n""\n""#define COMMON_FXC_H_\n""\n""\n""#include \"common_pragmas.h\"\n""\n""#include \"common_hlsl_cpp_consts.h\"\n""\n""\n""#ifdef NV3X\n""\n""#	define HALF half\n""\n""#	define HALF2 half2\n""\n""#	define HALF3 half3\n""\n""#	define HALF4 half4\n""\n""#	define HALF3x3 half3x3\n""\n""#	define HALF3x4 half3x4\n""\n""#	define HALF4x3 half4x3\n""\n""#	define HALF_CONSTANT( _constant )	((HALF)_constant)\n""\n""#else\n""\n""#	define HALF float\n""\n""#	define HALF2 float2\n""\n""#	define HALF3 float3\n""\n""#	define HALF4 float4\n""\n""#	define HALF3x3 float3x3\n""\n""#	define HALF3x4 float3x4\n""\n""#	define HALF4x3 float4x3\n""\n""#	define HALF_CONSTANT( _constant )	_constant\n""\n""#endif\n""\n""\n""// This is where all common code for both vertex and pixel shaders.\n""\n""#define OO_SQRT_3 0.57735025882720947f\n""\n""static const HALF3 bumpBasis[3] = {\n""\n""	HALF3( 0.81649661064147949f, 0.0f, OO_SQRT_3 ),\n""\n""	HALF3(  -0.40824833512306213f, 0.70710676908493042f, OO_SQRT_3 ),\n""\n""	HALF3(  -0.40824821591377258f, -0.7071068286895752f, OO_SQRT_3 )\n""\n""};\n""\n""static const HALF3 bumpBasisTranspose[3] = {\n""\n""	HALF3( 0.81649661064147949f, -0.40824833512306213f, -0.40824833512306213f ),\n""\n""	HALF3(  0.0f, 0.70710676908493042f, -0.7071068286895752f ),\n""\n""	HALF3(  OO_SQRT_3, OO_SQRT_3, OO_SQRT_3 )\n""\n""};\n""\n""\n""#if defined( _X360 )\n""\n""#define REVERSE_DEPTH_ON_X360 //uncomment to use D3DFMT_D24FS8 with an inverted depth viewport for better performance. Keep this in sync with the same named #define in public/shaderapi/shareddefs.h\n""\n""//Note that the reversal happens in the viewport. So ONLY reading back from a depth texture should be affected. Projected math is unaffected.\n""\n""#endif\n""\n""\n""HALF3 CalcReflectionVectorNormalized( HALF3 normal, HALF3 eyeVector )\n""\n""{\n""\n""	// FIXME: might be better of normalizing with a normalizing cube map and\n""\n""	// get rid of the dot( normal, normal )\n""\n""	// compute reflection vector r = 2 * ((n dot v)/(n dot n)) n - v\n""\n""	return 2.0 * ( dot( normal, eyeVector ) / dot( normal, normal ) ) * normal - eyeVector;\n""\n""}\n""\n""\n""HALF3 CalcReflectionVectorUnnormalized( HALF3 normal, HALF3 eyeVector )\n""\n""{\n""\n""	// FIXME: might be better of normalizing with a normalizing cube map and\n""\n""	// get rid of the dot( normal, normal )\n""\n""	// compute reflection vector r = 2 * ((n dot v)/(n dot n)) n - v\n""\n""	//  multiply all values through by N.N.  uniformly scaling reflection vector won't affect result\n""\n""	//  since it is used in a cubemap lookup\n""\n""	return (2.0*(dot( normal, eyeVector ))*normal) - (dot( normal, normal )*eyeVector);\n""\n""}\n""\n""\n""float3 HuePreservingColorClamp( float3 c )\n""\n""{\n""\n""	// Get the max of all of the color components and a specified maximum amount\n""\n""	float maximum = max( max( c.x, c.y ), max( c.z, 1.0f ) );\n""\n""\n""	return (c / maximum);\n""\n""}\n""\n""\n""HALF3 HuePreservingColorClamp( HALF3 c, HALF maxVal )\n""\n""{\n""\n""	// Get the max of all of the color components and a specified maximum amount\n""\n""	float maximum = max( max( c.x, c.y ), max( c.z, maxVal ) );\n""\n""	return (c * ( maxVal / maximum ) );\n""\n""}\n""\n""\n""#if (AA_CLAMP==1)\n""\n""HALF2 ComputeLightmapCoordinates( HALF4 Lightmap1and2Coord, HALF2 Lightmap3Coord ) \n""\n""{\n""\n""    HALF2 result = saturate(Lightmap1and2Coord.xy) * Lightmap1and2Coord.wz * 0.99;\n""\n""    result += Lightmap3Coord;\n""\n""    return result;\n""\n""}\n""\n""\n""void ComputeBumpedLightmapCoordinates( HALF4 Lightmap1and2Coord, HALF2 Lightmap3Coord,\n""\n""									  out HALF2 bumpCoord1,\n""\n""									  out HALF2 bumpCoord2,\n""\n""									  out HALF2 bumpCoord3 ) \n""\n""{\n""\n""    HALF2 result = saturate(Lightmap1and2Coord.xy) * Lightmap1and2Coord.wz * 0.99;\n""\n""    result += Lightmap3Coord;\n""\n""    bumpCoord1 = result + HALF2(Lightmap1and2Coord.z, 0);\n""\n""    bumpCoord2 = result + 2*HALF2(Lightmap1and2Coord.z, 0);\n""\n""    bumpCoord3 = result + 3*HALF2(Lightmap1and2Coord.z, 0);\n""\n""}\n""\n""#else\n""\n""HALF2 ComputeLightmapCoordinates( HALF4 Lightmap1and2Coord, HALF2 Lightmap3Coord ) \n""\n""{\n""\n""    return Lightmap1and2Coord.xy;\n""\n""}\n""\n""\n""void ComputeBumpedLightmapCoordinates( HALF4 Lightmap1and2Coord, HALF2 Lightmap3Coord,\n""\n""									  out HALF2 bumpCoord1,\n""\n""									  out HALF2 bumpCoord2,\n""\n""									  out HALF2 bumpCoord3 ) \n""\n""{\n""\n""    bumpCoord1 = Lightmap1and2Coord.xy;\n""\n""    bumpCoord2 = Lightmap1and2Coord.wz; // reversed order!!!\n""\n""    bumpCoord3 = Lightmap3Coord.xy;\n""\n""}\n""\n""#endif\n""\n""\n""// Versions of matrix multiply functions which force HLSL compiler to explictly use DOTs, \n""\n""// not giving it the option of using MAD expansion.  In a perfect world, the compiler would\n""\n""// always pick the best strategy, and these shouldn't be needed.. but.. well.. umm..\n""\n""//\n""\n""// lorenmcq\n""\n""\n""float3 mul3x3(float3 v, float3x3 m)\n""\n""{\n""\n""#if !defined( _X360 )\n""\n""    return float3(dot(v, transpose(m)[0]), dot(v, transpose(m)[1]), dot(v, transpose(m)[2]));\n""\n""#else\n""\n""	// xbox360 fxc.exe (new back end) borks with transposes, generates bad code\n""\n""	return mul( v, m );\n""\n""#endif\n""\n""}\n""\n""\n""float3 mul4x3(float4 v, float4x3 m)\n""\n""{\n""\n""#if !defined( _X360 )\n""\n""	return float3(dot(v, transpose(m)[0]), dot(v, transpose(m)[1]), dot(v, transpose(m)[2]));\n""\n""#else\n""\n""	// xbox360 fxc.exe (new back end) borks with transposes, generates bad code\n""\n""	return mul( v, m );\n""\n""#endif\n""\n""}\n""\n""\n""float3 DecompressHDR( float4 input )\n""\n""{\n""\n""	return input.rgb * input.a * MAX_HDR_OVERBRIGHT;\n""\n""}\n""\n""\n""float4 CompressHDR( float3 input )\n""\n""{\n""\n""	// FIXME: want to use min so that we clamp to white, but what happens if we \n""\n""	// have an albedo component that's less than 1/MAX_HDR_OVERBRIGHT?\n""\n""	//	float fMax = max( max( color.r, color.g ), color.b );\n""\n""	float4 output;\n""\n""	float fMax = min( min( input.r, input.g ), input.b );\n""\n""	if( fMax > 1.0f )\n""\n""	{\n""\n""		float oofMax = 1.0f / fMax;\n""\n""		output.rgb = oofMax * input.rgb;\n""\n""		output.a = min( fMax / MAX_HDR_OVERBRIGHT, 1.0f );\n""\n""	}\n""\n""	else\n""\n""	{\n""\n""		output.rgb = input.rgb;\n""\n""		output.a = 0.0f;\n""\n""	}\n""\n""	return output;\n""\n""}\n""\n""\n""\n""float3 LinearToGamma( const float3 f3linear )\n""\n""{\n""\n""	return pow( f3linear, 1.0f / 2.2f );\n""\n""}\n""\n""\n""float4 LinearToGamma( const float4 f4linear )\n""\n""{\n""\n""	return float4( pow( f4linear.xyz, 1.0f / 2.2f ), f4linear.w );\n""\n""}\n""\n""\n""float LinearToGamma( const float f1linear )\n""\n""{\n""\n""	return pow( f1linear, 1.0f / 2.2f );\n""\n""}\n""\n""\n""float3 GammaToLinear( const float3 gamma )\n""\n""{\n""\n""	return pow( gamma, 2.2f );\n""\n""}\n""\n""\n""float4 GammaToLinear( const float4 gamma )\n""\n""{\n""\n""	return float4( pow( gamma.xyz, 2.2f ), gamma.w );\n""\n""}\n""\n""\n""float GammaToLinear( const float gamma )\n""\n""{\n""\n""	return pow( gamma, 2.2f );\n""\n""}\n""\n""\n""// These two functions use the actual sRGB math\n""\n""float SrgbGammaToLinear( float flSrgbGammaValue )\n""\n""{\n""\n""	float x = saturate( flSrgbGammaValue );\n""\n""	return ( x <= 0.04045f ) ? ( x / 12.92f ) : ( pow( ( x + 0.055f ) / 1.055f, 2.4f ) );\n""\n""}\n""\n""\n""float SrgbLinearToGamma( float flLinearValue )\n""\n""{\n""\n""	float x = saturate( flLinearValue );\n""\n""	return ( x <= 0.0031308f ) ? ( x * 12.92f ) : ( 1.055f * pow( x, ( 1.0f / 2.4f ) ) ) - 0.055f;\n""\n""}\n""\n""\n""// These twofunctions use the XBox 360's exact piecewise linear algorithm\n""\n""float X360GammaToLinear( float fl360GammaValue )\n""\n""{\n""\n""	float flLinearValue;\n""\n""\n""	fl360GammaValue = saturate( fl360GammaValue );\n""\n""	if ( fl360GammaValue < ( 96.0f / 255.0f ) )\n""\n""	{\n""\n""		if ( fl360GammaValue < ( 64.0f / 255.0f ) )\n""\n""		{\n""\n""			flLinearValue = fl360GammaValue * 255.0f;\n""\n""		}\n""\n""		else\n""\n""		{\n""\n""			flLinearValue = fl360GammaValue * ( 255.0f * 2.0f ) - 64.0f;\n""\n""			flLinearValue += floor( flLinearValue * ( 1.0f / 512.0f ) );\n""\n""		}\n""\n""	}\n""\n""	else\n""\n""	{\n""\n""		if( fl360GammaValue < ( 192.0f / 255.0f ) )\n""\n""		{\n""\n""			flLinearValue = fl360GammaValue * ( 255.0f * 4.0f ) - 256.0f;\n""\n""			flLinearValue += floor( flLinearValue * ( 1.0f / 256.0f ) );\n""\n""		}\n""\n""		else\n""\n""		{\n""\n""			flLinearValue = fl360GammaValue * ( 255.0f * 8.0f ) - 1024.0f;\n""\n""			flLinearValue += floor( flLinearValue * ( 1.0f / 128.0f ) );\n""\n""		}\n""\n""	}\n""\n""\n""	flLinearValue *= 1.0f / 1023.0f;\n""\n""\n""	flLinearValue = saturate( flLinearValue );\n""\n""	return flLinearValue;\n""\n""}\n""\n""\n""float X360LinearToGamma( float flLinearValue )\n""\n""{\n""\n""	float fl360GammaValue;\n""\n""\n""	flLinearValue = saturate( flLinearValue );\n""\n""	if ( flLinearValue < ( 128.0f / 1023.0f ) )\n""\n""	{\n""\n""		if ( flLinearValue < ( 64.0f / 1023.0f ) )\n""\n""		{\n""\n""			fl360GammaValue = flLinearValue * ( 1023.0f * ( 1.0f / 255.0f ) );\n""\n""		}\n""\n""		else\n""\n""		{\n""\n""			fl360GammaValue = flLinearValue * ( ( 1023.0f / 2.0f ) * ( 1.0f / 255.0f ) ) + ( 32.0f / 255.0f );\n""\n""		}\n""\n""	}\n""\n""	else\n""\n""	{\n""\n""		if ( flLinearValue < ( 512.0f / 1023.0f ) )\n""\n""		{\n""\n""			fl360GammaValue = flLinearValue * ( ( 1023.0f / 4.0f ) * ( 1.0f / 255.0f ) ) + ( 64.0f / 255.0f );\n""\n""		}\n""\n""		else\n""\n""		{\n""\n""			fl360GammaValue = flLinearValue * ( ( 1023.0f /8.0f ) * ( 1.0f / 255.0f ) ) + ( 128.0f /255.0f ); // 1.0 -> 1.0034313725490196078431372549016\n""\n""			if ( fl360GammaValue > 1.0f )\n""\n""			{\n""\n""				fl360GammaValue = 1.0f;\n""\n""			}\n""\n""		}\n""\n""	}\n""\n""\n""	fl360GammaValue = saturate( fl360GammaValue );\n""\n""	return fl360GammaValue;\n""\n""}\n""\n""\n""float SrgbGammaTo360Gamma( float flSrgbGammaValue )\n""\n""{\n""\n""	float flLinearValue = SrgbGammaToLinear( flSrgbGammaValue );\n""\n""	float fl360GammaValue = X360LinearToGamma( flLinearValue );\n""\n""	return fl360GammaValue;\n""\n""}\n""\n""\n""float3 Vec3WorldToTangent( float3 iWorldVector, float3 iWorldNormal, float3 iWorldTangent, float3 iWorldBinormal )\n""\n""{\n""\n""	float3 vTangentVector;\n""\n""	vTangentVector.x = dot( iWorldVector.xyz, iWorldTangent.xyz );\n""\n""	vTangentVector.y = dot( iWorldVector.xyz, iWorldBinormal.xyz );\n""\n""	vTangentVector.z = dot( iWorldVector.xyz, iWorldNormal.xyz );\n""\n""	return vTangentVector.xyz; // Return without normalizing\n""\n""}\n""\n""\n""float3 Vec3WorldToTangentNormalized( float3 iWorldVector, float3 iWorldNormal, float3 iWorldTangent, float3 iWorldBinormal )\n""\n""{\n""\n""	return normalize( Vec3WorldToTangent( iWorldVector, iWorldNormal, iWorldTangent, iWorldBinormal ) );\n""\n""}\n""\n""\n""float3 Vec3TangentToWorld( float3 iTangentVector, float3 iWorldNormal, float3 iWorldTangent, float3 iWorldBinormal )\n""\n""{\n""\n""	float3 vWorldVector;\n""\n""	vWorldVector.xyz = iTangentVector.x * iWorldTangent.xyz;\n""\n""	vWorldVector.xyz += iTangentVector.y * iWorldBinormal.xyz;\n""\n""	vWorldVector.xyz += iTangentVector.z * iWorldNormal.xyz;\n""\n""	return vWorldVector.xyz; // Return without normalizing\n""\n""}\n""\n""\n""float3 Vec3TangentToWorldNormalized( float3 iTangentVector, float3 iWorldNormal, float3 iWorldTangent, float3 iWorldBinormal )\n""\n""{\n""\n""	return normalize( Vec3TangentToWorld( iTangentVector, iWorldNormal, iWorldTangent, iWorldBinormal ) );\n""\n""}\n""\n""\n""#endif //#ifndef COMMON_FXC_H_\n""\n""\n";