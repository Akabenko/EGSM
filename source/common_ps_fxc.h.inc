const char common_ps_fxc_h[] = "//========= Copyright Valve Corporation, All rights reserved. ============//\n""//\n""// Purpose: Common pixel shader code\n""//\n""// $NoKeywords: $\n""//\n""//=============================================================================//\n""#ifndef COMMON_PS_FXC_H_\n""#define COMMON_PS_FXC_H_\n""\n""#include \"common_fxc.h\"\n""\n""// Put global skip commands here. . make sure and check that the appropriate vars are defined\n""// so these aren't used on the wrong shaders!\n""\n""// --------------------------------------------------------------------------------\n""// HDR should never be enabled if we don't aren't running in float or integer HDR mode.\n""// SKIP: defined $HDRTYPE && defined $HDRENABLED && !$HDRTYPE && $HDRENABLED\n""// --------------------------------------------------------------------------------\n""// We don't ever write water fog to dest alpha if we aren't doing water fog.\n""// SKIP: defined $PIXELFOGTYPE && defined $WRITEWATERFOGTODESTALPHA && ( $PIXELFOGTYPE != 1 ) && $WRITEWATERFOGTODESTALPHA\n""// --------------------------------------------------------------------------------\n""// We don't need fog in the pixel shader if we aren't in float fog mode2\n""// NOSKIP: defined $HDRTYPE && defined $HDRENABLED && defined $PIXELFOGTYPE && $HDRTYPE != HDR_TYPE_FLOAT && $FOGTYPE != 0\n""// --------------------------------------------------------------------------------\n""// We don't do HDR and LIGHTING_PREVIEW at the same time since it's running LDR in hammer.\n""//  SKIP: defined $LIGHTING_PREVIEW && defined $HDRTYPE && $LIGHTING_PREVIEW && $HDRTYPE != 0\n""// --------------------------------------------------------------------------------\n""// Ditch all fastpath attempts if we are doing LIGHTING_PREVIEW.\n""//	SKIP: defined $LIGHTING_PREVIEW && defined $FASTPATHENVMAPTINT && $LIGHTING_PREVIEW && $FASTPATHENVMAPTINT\n""//	SKIP: defined $LIGHTING_PREVIEW && defined $FASTPATHENVMAPCONTRAST && $LIGHTING_PREVIEW && $FASTPATHENVMAPCONTRAST\n""//	SKIP: defined $LIGHTING_PREVIEW && defined $FASTPATH && $LIGHTING_PREVIEW && $FASTPATH\n""// --------------------------------------------------------------------------------\n""// Ditch flashlight depth when flashlight is disabled\n""//  SKIP: ($FLASHLIGHT || $FLASHLIGHTSHADOWS) && $LIGHTING_PREVIEW\n""// --------------------------------------------------------------------------------\n""\n""// System defined pixel shader constants\n""\n""#if defined( _X360 )\n""const bool g_bHighQualityShadows : register( b0 );\n""#endif\n""\n""// NOTE: w == 1.0f / (Dest alpha compressed depth range).\n""const float4 g_LinearFogColor : register( c29 );\n""#define OO_DESTALPHA_DEPTH_RANGE (g_LinearFogColor.w)\n""\n""// Linear and gamma light scale values\n""const float4 cLightScale : register( c30 );\n""#define LINEAR_LIGHT_SCALE (cLightScale.x)\n""#define LIGHT_MAP_SCALE (cLightScale.y)\n""#define ENV_MAP_SCALE (cLightScale.z)\n""#define GAMMA_LIGHT_SCALE (cLightScale.w)\n""\n""// Flashlight constants\n""#if defined(SHADER_MODEL_PS_2_0) || defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0)\n"" const float4 cFlashlightColor       : register( c28 );\n"" const float4 cFlashlightScreenScale : register( c31 ); // .zw are currently unused\n"" #define flFlashlightNoLambertValue cFlashlightColor.w // This is either 0.0 or 2.0\n""#endif\n""\n""#define HDR_INPUT_MAP_SCALE 16.0f\n""\n""#define TONEMAP_SCALE_NONE 0\n""#define TONEMAP_SCALE_LINEAR 1\n""#define TONEMAP_SCALE_GAMMA 2\n""\n""#define PIXEL_FOG_TYPE_NONE -1 //MATERIAL_FOG_NONE is handled by PIXEL_FOG_TYPE_RANGE, this is for explicitly disabling fog in the shader\n""#define PIXEL_FOG_TYPE_RANGE 0 //range+none packed together in ps2b. Simply none in ps20 (instruction limits)\n""#define PIXEL_FOG_TYPE_HEIGHT 1\n""\n""// If you change these, make the corresponding change in hardwareconfig.cpp\n""#define NVIDIA_PCF_POISSON	0\n""#define ATI_NOPCF			1\n""#define ATI_NO_PCF_FETCH4	2\n""\n""struct LPREVIEW_PS_OUT\n""{\n""	float4 color : COLOR0;\n""	float4 normal : COLOR1;\n""	float4 position : COLOR2;\n""	float4 flags : COLOR3;\n""};\n""\n""/*\n""// unused\n""HALF Luminance( HALF3 color )\n""{\n""	return dot( color, HALF3( HALF_CONSTANT(0.30f), HALF_CONSTANT(0.59f), HALF_CONSTANT(0.11f) ) );\n""}\n""*/\n""\n""/*\n""// unused\n""HALF LuminanceScaled( HALF3 color )\n""{\n""	return dot( color, HALF3( HALF_CONSTANT(0.30f) / MAX_HDR_OVERBRIGHT, HALF_CONSTANT(0.59f) / MAX_HDR_OVERBRIGHT, HALF_CONSTANT(0.11f) / MAX_HDR_OVERBRIGHT ) );\n""}\n""*/\n""\n""/*\n""// unused\n""HALF AvgColor( HALF3 color )\n""{\n""	return dot( color, HALF3( HALF_CONSTANT(0.33333f), HALF_CONSTANT(0.33333f), HALF_CONSTANT(0.33333f) ) );\n""}\n""*/\n""\n""/*\n""// unused\n""HALF4 DiffuseBump( sampler lightmapSampler,\n""                   float2  lightmapTexCoord1,\n""                   float2  lightmapTexCoord2,\n""                   float2  lightmapTexCoord3,\n""                   HALF3   normal )\n""{\n""	HALF3 lightmapColor1 = tex2D( lightmapSampler, lightmapTexCoord1 );\n""	HALF3 lightmapColor2 = tex2D( lightmapSampler, lightmapTexCoord2 );\n""	HALF3 lightmapColor3 = tex2D( lightmapSampler, lightmapTexCoord3 );\n""\n""	HALF3 diffuseLighting;\n""	diffuseLighting = saturate( dot( normal, bumpBasis[0] ) ) * lightmapColor1 +\n""					  saturate( dot( normal, bumpBasis[1] ) ) * lightmapColor2 +\n""					  saturate( dot( normal, bumpBasis[2] ) ) * lightmapColor3;\n""\n""	return HALF4( diffuseLighting, LuminanceScaled( diffuseLighting ) );\n""}\n""*/\n""\n""\n""/*\n""// unused\n""HALF Fresnel( HALF3 normal,\n""              HALF3 eye,\n""              HALF2 scaleBias )\n""{\n""	HALF fresnel = HALF_CONSTANT(1.0f) - dot( normal, eye );\n""	fresnel = pow( fresnel, HALF_CONSTANT(5.0f) );\n""\n""	return fresnel * scaleBias.x + scaleBias.y;\n""}\n""*/\n""\n""/*\n""// unused\n""HALF4 GetNormal( sampler normalSampler,\n""                 float2 normalTexCoord )\n""{\n""	HALF4 normal = tex2D( normalSampler, normalTexCoord );\n""	normal.rgb = HALF_CONSTANT(2.0f) * normal.rgb - HALF_CONSTANT(1.0f);\n""\n""	return normal;\n""}\n""*/\n""\n""// Needs to match NormalDecodeMode_t enum in imaterialsystem.h\n""#define NORM_DECODE_NONE			0\n""#define NORM_DECODE_ATI2N			1\n""#define NORM_DECODE_ATI2N_ALPHA		2\n""\n""float4 DecompressNormal( sampler NormalSampler, float2 tc, int nDecompressionMode, sampler AlphaSampler )\n""{\n""	float4 normalTexel = tex2D( NormalSampler, tc );\n""	float4 result;\n""\n""	if ( nDecompressionMode == NORM_DECODE_NONE )\n""	{\n""		result = float4(normalTexel.xyz * 2.0f - 1.0f, normalTexel.a );\n""	}\n""	else if ( nDecompressionMode == NORM_DECODE_ATI2N )\n""	{\n""		result.xy = normalTexel.xy * 2.0f - 1.0f;\n""		result.z = sqrt( 1.0f - dot(result.xy, result.xy) );\n""		result.a = 1.0f;\n""	}\n""	else // ATI2N plus ATI1N for alpha\n""	{\n""		result.xy = normalTexel.xy * 2.0f - 1.0f;\n""		result.z = sqrt( 1.0f - dot(result.xy, result.xy) );\n""		result.a = tex2D( AlphaSampler, tc ).x;					// Note that this comes in on the X channel\n""	}\n""\n""	return result;\n""}\n""\n""float4 DecompressNormal( sampler NormalSampler, float2 tc, int nDecompressionMode )\n""{\n""	return DecompressNormal( NormalSampler, tc, nDecompressionMode, NormalSampler );\n""}\n""\n""\n""HALF3 NormalizeWithCubemap( sampler normalizeSampler, HALF3 input )\n""{\n""//	return texCUBE( normalizeSampler, input ) * 2.0f - 1.0f;\n""	return texCUBE( normalizeSampler, input );\n""}\n""\n""/*\n""HALF4 EnvReflect( sampler envmapSampler,\n""				 sampler normalizeSampler,\n""				 HALF3 normal,\n""				 float3 eye,\n""				 HALF2 fresnelScaleBias )\n""{\n""	HALF3 normEye = NormalizeWithCubemap( normalizeSampler, eye );\n""	HALF fresnel = Fresnel( normal, normEye, fresnelScaleBias );\n""	HALF3 reflect = CalcReflectionVectorUnnormalized( normal, eye );\n""	return texCUBE( envmapSampler, reflect );\n""}\n""*/\n""\n""float CalcWaterFogAlpha( const float flWaterZ, const float flEyePosZ, const float flWorldPosZ, const float flProjPosZ, const float flFogOORange )\n""{\n""//	float flDepthFromWater = flWaterZ - flWorldPosZ + 2.0f; // hackity hack . .this is for the DF_FUDGE_UP in view_scene.cpp\n""	float flDepthFromWater = flWaterZ - flWorldPosZ;\n""\n""	// if flDepthFromWater < 0, then set it to 0\n""	// This is the equivalent of moving the vert to the water surface if it's above the water surface\n""	// We'll do this with the saturate at the end instead.\n""//	flDepthFromWater = max( 0.0f, flDepthFromWater );\n""\n""	// Calculate the ratio of water fog to regular fog (ie. how much of the distance from the viewer\n""	// to the vert is actually underwater.\n""	float flDepthFromEye = flEyePosZ - flWorldPosZ;\n""	float f = saturate(flDepthFromWater * (1.0/flDepthFromEye));\n""\n""	// $tmp.w is now the distance that we see through water.\n""	return saturate(f * flProjPosZ * flFogOORange);\n""}\n""\n""float CalcRangeFog( const float flProjPosZ, const float flFogStartOverRange, const float flFogMaxDensity, const float flFogOORange )\n""{\n""#if !(defined(SHADER_MODEL_PS_1_1) || defined(SHADER_MODEL_PS_1_4) || defined(SHADER_MODEL_PS_2_0)) //Minimum requirement of ps2b\n""	return saturate( min( flFogMaxDensity, (flProjPosZ * flFogOORange) - flFogStartOverRange ) );\n""#else\n""	return 0.0f; //ps20 shaders will never have range fog enabled because too many ran out of slots.\n""#endif\n""}\n""\n""float CalcPixelFogFactor( int iPIXELFOGTYPE, const float4 fogParams, const float flEyePosZ, const float flWorldPosZ, const float flProjPosZ )\n""{\n""	float retVal;\n""	if ( iPIXELFOGTYPE == PIXEL_FOG_TYPE_NONE )\n""	{\n""		retVal = 0.0f;\n""	}\n""	if ( iPIXELFOGTYPE == PIXEL_FOG_TYPE_RANGE ) //range fog, or no fog depending on fog parameters\n""	{\n""		retVal = CalcRangeFog( flProjPosZ, fogParams.x, fogParams.z, fogParams.w );\n""	}\n""	else if ( iPIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT ) //height fog\n""	{\n""		retVal = CalcWaterFogAlpha( fogParams.y, flEyePosZ, flWorldPosZ, flProjPosZ, fogParams.w );\n""	}\n""\n""	return retVal;\n""}\n""\n""//g_FogParams not defined by default, but this is the same layout for every shader that does define it\n""#define g_fPixelFogType					g_ShaderControls.x\n""#define g_fWriteDepthToAlpha			g_ShaderControls.y\n""#define g_fWriteWaterFogToDestAlpha		g_ShaderControls.z\n""#define g_fVertexAlpha					g_ShaderControls.w\n""\n""#define g_FogEndOverRange	g_FogParams.x\n""#define g_WaterZ			g_FogParams.y\n""#define g_FogMaxDensity		g_FogParams.z\n""#define g_FogOORange		g_FogParams.w\n""\n""float3 BlendPixelFog( const float3 vShaderColor, float pixelFogFactor, const float3 vFogColor, const int iPIXELFOGTYPE )\n""{\n""	if( iPIXELFOGTYPE == PIXEL_FOG_TYPE_RANGE ) //either range fog or no fog depending on fog parameters and whether this is ps20 or ps2b\n""	{\n""#	if !(defined(SHADER_MODEL_PS_1_1) || defined(SHADER_MODEL_PS_1_4) || defined(SHADER_MODEL_PS_2_0)) //Minimum requirement of ps2b\n""		pixelFogFactor = saturate( pixelFogFactor );\n""		return lerp( vShaderColor.rgb, vFogColor.rgb, pixelFogFactor * pixelFogFactor ); //squaring the factor will get the middle range mixing closer to hardware fog\n""#	else\n""		return vShaderColor;\n""#	endif\n""	}\n""	else if( iPIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT )\n""	{\n""		return lerp( vShaderColor.rgb, vFogColor.rgb, saturate( pixelFogFactor ) );\n""	}\n""	return vShaderColor;\n""}\n""\n""\n""#if ((defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0)) && ( CONVERT_TO_SRGB != 0 ) )\n""sampler1D GammaTableSampler : register( s15 );\n""\n""float3 SRGBOutput( const float3 vShaderColor )\n""{	\n""	//On ps2b capable hardware we always have the linear->gamma conversion table texture in sampler s15.\n""	float3 result;\n""	result.r = tex1D( GammaTableSampler, vShaderColor.r ).r;\n""	result.g = tex1D( GammaTableSampler, vShaderColor.g ).r;\n""	result.b = tex1D( GammaTableSampler, vShaderColor.b ).r;\n""	return result;	\n""}\n""\n""#else\n""\n""float3 SRGBOutput( const float3 vShaderColor )\n""{\n""	return vShaderColor; //ps 1.1, 1.4, and 2.0 never do srgb conversion in the pixel shader\n""}\n""\n""#endif\n""\n""\n""float SoftParticleDepth( float flDepth )\n""{\n""	return flDepth * OO_DESTALPHA_DEPTH_RANGE;\n""}\n""\n""\n""float DepthToDestAlpha( const float flProjZ )\n""{\n""#if !(defined(SHADER_MODEL_PS_1_1) || defined(SHADER_MODEL_PS_1_4) || defined(SHADER_MODEL_PS_2_0)) //Minimum requirement of ps2b\n""	return SoftParticleDepth( flProjZ );\n""#else\n""	return 1.0f;\n""#endif\n""}\n""\n""\n""float4 FinalOutput( const float4 vShaderColor, float pixelFogFactor, const int iPIXELFOGTYPE, const int iTONEMAP_SCALE_TYPE, const bool bWriteDepthToDestAlpha = false, const float flProjZ = 1.0f )\n""{\n""	float4 result;\n""	if( iTONEMAP_SCALE_TYPE == TONEMAP_SCALE_LINEAR )\n""	{\n""		result.rgb = vShaderColor.rgb * LINEAR_LIGHT_SCALE;\n""	}\n""	else if( iTONEMAP_SCALE_TYPE == TONEMAP_SCALE_GAMMA )\n""	{\n""		result.rgb = vShaderColor.rgb * GAMMA_LIGHT_SCALE;\n""	}\n""	else if( iTONEMAP_SCALE_TYPE == TONEMAP_SCALE_NONE )\n""	{\n""		result.rgb = vShaderColor.rgb;\n""	}\n""	\n""	if( bWriteDepthToDestAlpha )\n""		result.a = DepthToDestAlpha( flProjZ );\n""	else\n""		result.a = vShaderColor.a;\n""\n""	result.rgb = BlendPixelFog( result.rgb, pixelFogFactor, g_LinearFogColor.rgb, iPIXELFOGTYPE );\n""	\n""#if !(defined(SHADER_MODEL_PS_1_1) || defined(SHADER_MODEL_PS_1_4) || defined(SHADER_MODEL_PS_2_0)) //Minimum requirement of ps2b\n""	result.rgb = SRGBOutput( result.rgb ); //SRGB in pixel shader conversion\n""#endif\n""\n""	return result;\n""}\n""\n""LPREVIEW_PS_OUT FinalOutput( const LPREVIEW_PS_OUT vShaderColor, float pixelFogFactor, const int iPIXELFOGTYPE, const int iTONEMAP_SCALE_TYPE )\n""{\n""	LPREVIEW_PS_OUT result;\n""	result.color = FinalOutput( vShaderColor.color, pixelFogFactor, iPIXELFOGTYPE, iTONEMAP_SCALE_TYPE );\n""	result.normal.rgb = SRGBOutput( vShaderColor.normal.rgb );\n""	result.normal.a = vShaderColor.normal.a;\n""\n""	result.position.rgb = SRGBOutput( vShaderColor.position.rgb );\n""	result.position.a = vShaderColor.position.a;\n""\n""	result.flags.rgb = SRGBOutput( vShaderColor.flags.rgb );	\n""	result.flags.a = vShaderColor.flags.a;\n""\n""	return result;\n""}\n""\n""\n""\n""\n""float RemapValClamped( float val, float A, float B, float C, float D)\n""{\n""	float cVal = (val - A) / (B - A);\n""	cVal = saturate( cVal );\n""\n""	return C + (D - C) * cVal;\n""}\n""\n""\n""//===================================================================================//\n""// This is based on Natasha Tatarchuk's Parallax Occlusion Mapping (ATI)\n""//===================================================================================//\n""// INPUT:\n""//		inTexCoord: \n""//			the texcoord for the height/displacement map before parallaxing\n""//\n""//		vParallax:\n""//			Compute initial parallax displacement direction:\n""//			float2 vParallaxDirection = normalize( vViewTS.xy );\n""//			float fLength = length( vViewTS );\n""//			float fParallaxLength = sqrt( fLength * fLength - vViewTS.z * vViewTS.z ) / vViewTS.z; \n""//			Out.vParallax = vParallaxDirection * fParallaxLength * fProjectedBumpHeight;\n""//\n""//		vNormal:\n""//			tangent space normal\n""//\n""//		vViewW: \n""//			float3 vViewW = /*normalize*/(mul( matViewInverse, float4( 0, 0, 0, 1)) - inPosition );\n""//\n""// OUTPUT:\n""//		the new texcoord after parallaxing\n""float2 CalcParallaxedTexCoord( float2 inTexCoord, float2 vParallax, float3 vNormal, \n""							   float3 vViewW, sampler HeightMapSampler )\n""{\n""	const int nMinSamples = 8;\n""	const int nMaxSamples = 50;\n""\n""   //  Normalize the incoming view vector to avoid artifacts:\n""//   vView = normalize( vView );\n""   vViewW = normalize( vViewW );\n""//   vLight = normalize( vLight );\n""   \n""   // Change the number of samples per ray depending on the viewing angle\n""   // for the surface. Oblique angles require smaller step sizes to achieve \n""   // more accurate precision         \n""   int nNumSteps = (int) lerp( nMaxSamples, nMinSamples, dot( vViewW, vNormal ) );\n""      \n""   float4 cResultColor = float4( 0, 0, 0, 1 );\n""         \n""   //===============================================//\n""   // Parallax occlusion mapping offset computation //\n""   //===============================================//      \n""   float fCurrHeight = 0.0;\n""   float fStepSize   = 1.0 / (float) nNumSteps;\n""   float fPrevHeight = 1.0;\n""   float fNextHeight = 0.0;\n""\n""   int nStepIndex = 0;\n""//   bool bCondition = true;\n""   \n""   float2 dx = ddx( inTexCoord );\n""   float2 dy = ddy( inTexCoord );\n""   \n""   float2 vTexOffsetPerStep = fStepSize * vParallax;\n""   \n""   float2 vTexCurrentOffset = inTexCoord;\n""   float fCurrentBound = 1.0;\n""   \n""   float x = 0;\n""   float y = 0;\n""   float xh = 0;\n""   float yh = 0;   \n""   \n""   float2 texOffset2 = 0;\n""   \n""   bool bCondition = true;\n""   while ( bCondition == true && nStepIndex < nNumSteps ) \n""   {\n""      vTexCurrentOffset -= vTexOffsetPerStep;\n""      \n""      fCurrHeight = tex2Dgrad( HeightMapSampler, vTexCurrentOffset, dx, dy ).r;\n""            \n""      fCurrentBound -= fStepSize;\n""      \n""      if ( fCurrHeight > fCurrentBound ) \n""      {                \n""         x  = fCurrentBound; \n""         y  = fCurrentBound + fStepSize; \n""         xh = fCurrHeight;\n""         yh = fPrevHeight;\n""         \n""         texOffset2 = vTexCurrentOffset - vTexOffsetPerStep;\n""                  \n""         bCondition = false;\n""      }\n""      else\n""      {\n""         nStepIndex++;\n""         fPrevHeight = fCurrHeight;\n""      }\n""     \n""   }   // End of while ( bCondition == true && nStepIndex > -1 )#else\n""\n""   fCurrentBound -= fStepSize;\n""   \n""   float fParallaxAmount;\n""   float numerator = (x * (y - yh) - y * (x - xh));\n""   float denomenator = ((y - yh) - (x - xh));\n""	// avoid NaN generation\n""   if( ( numerator == 0.0f ) && ( denomenator == 0.0f ) )\n""   {\n""      fParallaxAmount = 0.0f;\n""   }\n""   else\n""   {\n""      fParallaxAmount = numerator / denomenator;\n""   }\n""\n""   float2 vParallaxOffset = vParallax * (1 - fParallaxAmount );\n""\n""   // Sample the height at the next possible step:\n""   fNextHeight = tex2Dgrad( HeightMapSampler, texOffset2, dx, dy ).r;\n""   \n""   // Original offset:\n""   float2 texSampleBase = inTexCoord - vParallaxOffset;\n""\n""   return texSampleBase;\n""\n""#if 0\n""   cResultColor.rgb = ComputeDiffuseColor( texSampleBase, vLight );\n""        \n""   float fBound = 1.0 - fStepSize * nStepIndex;\n""   if ( fNextHeight < fCurrentBound )\n""//    if( 0 )\n""   {\n""      //void DoIteration( in float2 vParallaxJittered, in float3 vLight, inout float4 cResultColor )\n""      //cResultColor.rgb = float3(1,0,0);\n""      DoIteration( vParallax + vPixelSize, vLight, fStepSize, inTexCoord, nStepIndex, dx, dy, fBound, cResultColor );\n""      DoIteration( vParallax - vPixelSize, vLight, fStepSize, inTexCoord, nStepIndex, dx, dy, fBound, cResultColor );\n""      DoIteration( vParallax + float2( -vPixelSize.x, vPixelSize.y ), vLight, fStepSize, inTexCoord, nStepIndex, dx, dy, fBound, cResultColor );\n""      DoIteration( vParallax + float2( vPixelSize.x, -vPixelSize.y ), vLight, fStepSize, inTexCoord, nStepIndex, dx, dy, fBound, cResultColor );\n""\n""      cResultColor.rgb /= 5;\n""//      cResultColor.rgb = float3( 1.0f, 0.0f, 0.0f );\n""   }   // End of if ( fNextHeight < fCurrentBound )\n""  \n""#if DOSHADOWS\n""   {\n""      //============================================//\n""      // Soft shadow and self-occlusion computation //\n""      //============================================//\n""      // Compute the blurry shadows (note that this computation takes into \n""      // account self-occlusion for shadow computation):\n""      float sh0 =  tex2D( sNormalMap, texSampleBase).w;\n""      float shA = (tex2D( sNormalMap, texSampleBase + inXY * 0.88 ).w - sh0 - 0.88 ) *  1 * fShadowSoftening;\n""      float sh9 = (tex2D( sNormalMap, texSampleBase + inXY * 0.77 ).w - sh0 - 0.77 ) *  2 * fShadowSoftening;\n""      float sh8 = (tex2D( sNormalMap, texSampleBase + inXY * 0.66 ).w - sh0 - 0.66 ) *  4 * fShadowSoftening;\n""      float sh7 = (tex2D( sNormalMap, texSampleBase + inXY * 0.55 ).w - sh0 - 0.55 ) *  6 * fShadowSoftening;\n""      float sh6 = (tex2D( sNormalMap, texSampleBase + inXY * 0.44 ).w - sh0 - 0.44 ) *  8 * fShadowSoftening;\n""      float sh5 = (tex2D( sNormalMap, texSampleBase + inXY * 0.33 ).w - sh0 - 0.33 ) * 10 * fShadowSoftening;\n""      float sh4 = (tex2D( sNormalMap, texSampleBase + inXY * 0.22 ).w - sh0 - 0.22 ) * 12 * fShadowSoftening;\n""      \n""      // Compute the actual shadow strength:\n""      float fShadow = 1 - max( max( max( max( max( max( shA, sh9 ), sh8 ), sh7 ), sh6 ), sh5 ), sh4 );\n""\n""      cResultColor.rgb *= fShadow * 0.6 + 0.4;\n""   }\n""#endif\n""   \n""   return cResultColor;\n""#endif\n""}\n""\n""\n""//======================================//\n""// HSL Color space conversion routines  //\n""//======================================//\n""\n""#define HUE          0\n""#define SATURATION   1\n""#define LIGHTNESS    2\n""\n""// Convert from RGB to HSL color space\n""float4 RGBtoHSL( float4 inColor )\n""{\n""   float h, s;\n""   float flMax = max( inColor.r, max( inColor.g, inColor.b ) );\n""   float flMin = min( inColor.r, min( inColor.g, inColor.b ) );\n""   \n""   float l = (flMax + flMin) / 2.0f;\n""   \n""   if (flMax == flMin)   // achromatic case\n""   {\n""      s = h = 0;\n""   }\n""   else                  // chromatic case\n""   {\n""      // Next, calculate the hue\n""      float delta = flMax - flMin;\n""      \n""      // First, calculate the saturation\n""      if (l < 0.5f)      // If we're in the lower hexcone\n""      {\n""         s = delta/(flMax + flMin);\n""      }\n""      else\n""      {\n""         s = delta/(2 - flMax - flMin);\n""      }\n""      \n""      if ( inColor.r == flMax )\n""      {\n""         h = (inColor.g - inColor.b)/delta;      // color between yellow and magenta\n""      }\n""      else if ( inColor.g == flMax )\n""      {\n""         h = 2 + (inColor.b - inColor.r)/delta;  // color between cyan and yellow\n""      }\n""      else // blue must be max\n""      {\n""         h = 4 + (inColor.r - inColor.g)/delta;  // color between magenta and cyan\n""      }\n""      \n""      h *= 60.0f;\n""      \n""      if (h < 0.0f)\n""      {\n""         h += 360.0f;\n""      }\n""      \n""      h /= 360.0f;  \n""   }\n""\n""   return float4 (h, s, l, 1.0f);\n""}\n""\n""float HueToRGB( float v1, float v2, float vH )\n""{\n""   float fResult = v1;\n""   \n""   vH = fmod (vH + 1.0f, 1.0f);\n""\n""   if ( ( 6.0f * vH ) < 1.0f )\n""   {\n""      fResult = ( v1 + ( v2 - v1 ) * 6.0f * vH );\n""   }\n""   else if ( ( 2.0f * vH ) < 1.0f )\n""   {\n""      fResult = ( v2 );\n""   }\n""   else if ( ( 3.0f * vH ) < 2.0f )\n""   {\n""      fResult = ( v1 + ( v2 - v1 ) * ( ( 2.0f / 3.0f ) - vH ) * 6.0f );\n""   }\n""\n""   return fResult;\n""}\n""\n""// Convert from HSL to RGB color space\n""float4 HSLtoRGB( float4 hsl )\n""{\n""   float r, g, b;\n""   float h = hsl[HUE];\n""   float s = hsl[SATURATION];\n""   float l = hsl[LIGHTNESS];\n""\n""   if ( s == 0 )\n""   {\n""      r = g = b = l;\n""   }\n""   else\n""   {\n""      float v1, v2;\n""      \n""      if ( l < 0.5f )\n""         v2 = l * ( 1.0f + s );\n""      else\n""         v2 = ( l + s ) - ( s * l );\n""\n""      v1 = 2 * l - v2;\n""\n""      r = HueToRGB( v1, v2, h + ( 1.0f / 3.0f ) );\n""      g = HueToRGB( v1, v2, h );\n""      b = HueToRGB( v1, v2, h - ( 1.0f / 3.0f ) );\n""   }\n""  \n""   return float4( r, g, b, 1.0f );\n""}\n""\n""\n""// texture combining modes for combining base and detail/basetexture2\n""#define TCOMBINE_RGB_EQUALS_BASE_x_DETAILx2 0				// original mode\n""#define TCOMBINE_RGB_ADDITIVE 1								// base.rgb+detail.rgb*fblend\n""#define TCOMBINE_DETAIL_OVER_BASE 2\n""#define TCOMBINE_FADE 3										// straight fade between base and detail.\n""#define TCOMBINE_BASE_OVER_DETAIL 4                         // use base alpha for blend over detail\n""#define TCOMBINE_RGB_ADDITIVE_SELFILLUM 5                   // add detail color post lighting\n""#define TCOMBINE_RGB_ADDITIVE_SELFILLUM_THRESHOLD_FADE 6\n""#define TCOMBINE_MOD2X_SELECT_TWO_PATTERNS 7				// use alpha channel of base to select between mod2x channels in r+a of detail\n""#define TCOMBINE_MULTIPLY 8\n""#define TCOMBINE_MASK_BASE_BY_DETAIL_ALPHA 9                // use alpha channel of detail to mask base\n""#define TCOMBINE_SSBUMP_BUMP 10								// use detail to modulate lighting as an ssbump\n""#define TCOMBINE_SSBUMP_NOBUMP 11					// detail is an ssbump but use it as an albedo. shader does the magic here - no user needs to specify mode 11\n""\n""float4 TextureCombine( float4 baseColor, float4 detailColor, int combine_mode,\n""					   float fBlendFactor )\n""{\n""	if ( combine_mode == TCOMBINE_MOD2X_SELECT_TWO_PATTERNS)\n""	{\n""		float3 dc=lerp(detailColor.r,detailColor.a, baseColor.a);\n""		baseColor.rgb*=lerp(float3(1,1,1),2.0*dc,fBlendFactor);\n""	}\n""	if ( combine_mode == TCOMBINE_RGB_EQUALS_BASE_x_DETAILx2)\n""		baseColor.rgb*=lerp(float3(1,1,1),2.0*detailColor.rgb,fBlendFactor);\n""	if ( combine_mode == TCOMBINE_RGB_ADDITIVE )\n"" 		baseColor.rgb += fBlendFactor * detailColor.rgb;\n""	if ( combine_mode == TCOMBINE_DETAIL_OVER_BASE )\n""	{\n""		float fblend=fBlendFactor * detailColor.a;\n""		baseColor.rgb = lerp( baseColor.rgb, detailColor.rgb, fblend);\n""	}\n""	if ( combine_mode == TCOMBINE_FADE )\n""	{\n""		baseColor = lerp( baseColor, detailColor, fBlendFactor);\n""	}\n""	if ( combine_mode == TCOMBINE_BASE_OVER_DETAIL )\n""	{\n""		float fblend=fBlendFactor * (1-baseColor.a);\n""		baseColor.rgb = lerp( baseColor.rgb, detailColor.rgb, fblend );\n""		baseColor.a = detailColor.a;\n""	}\n""	if ( combine_mode == TCOMBINE_MULTIPLY )\n""	{\n""		baseColor = lerp( baseColor, baseColor*detailColor, fBlendFactor);\n""	}\n""\n""	if (combine_mode == TCOMBINE_MASK_BASE_BY_DETAIL_ALPHA )\n""	{\n""		baseColor.a = lerp( baseColor.a, baseColor.a*detailColor.a, fBlendFactor );\n""	}\n""	if ( combine_mode == TCOMBINE_SSBUMP_NOBUMP )\n""	{\n""		baseColor.rgb = baseColor.rgb * dot( detailColor.rgb, 2.0/3.0 );\n""	}\n""	return baseColor;\n""}\n""\n""float3 lerp5(float3 f1, float3 f2, float i1, float i2, float x)\n""{\n""  return f1+(f2-f1)*(x-i1)/(i2-i1);\n""}\n""\n""float3 TextureCombinePostLighting( float3 lit_baseColor, float4 detailColor, int combine_mode,\n""								   float fBlendFactor )\n""{\n""	if ( combine_mode == TCOMBINE_RGB_ADDITIVE_SELFILLUM )\n"" 		lit_baseColor += fBlendFactor * detailColor.rgb;\n""	if ( combine_mode == TCOMBINE_RGB_ADDITIVE_SELFILLUM_THRESHOLD_FADE )\n""	{\n"" 		// fade in an unusual way - instead of fading out color, remap an increasing band of it from\n"" 		// 0..1\n""		//if (fBlendFactor > 0.5)\n""		//	lit_baseColor += min(1, (1.0/fBlendFactor)*max(0, detailColor.rgb-(1-fBlendFactor) ) );\n""		//else\n""		//	lit_baseColor += 2*fBlendFactor*2*max(0, detailColor.rgb-.5);\n""\n""		float f = fBlendFactor - 0.5;\n""		float fMult = (f >= 0) ? 1.0/fBlendFactor : 4*fBlendFactor;\n""		float fAdd = (f >= 0) ? 1.0-fMult : -0.5*fMult;\n""		lit_baseColor += saturate(fMult * detailColor.rgb + fAdd);\n""	}\n""	return lit_baseColor;\n""}\n""\n""//NOTE: On X360. fProjZ is expected to be pre-reversed for cheaper math here in the pixel shader\n""float DepthFeathering( sampler DepthSampler, const float2 vScreenPos, float fProjZ, float fProjW, float4 vDepthBlendConstants )\n""{\n""#	if ( !(defined(SHADER_MODEL_PS_1_1) || defined(SHADER_MODEL_PS_1_4) || defined(SHADER_MODEL_PS_2_0)) ) //minimum requirement of ps2b\n""	{\n""		float flFeatheredAlpha;\n""		float2 flDepths;\n""#define flSceneDepth flDepths.x\n""#define flSpriteDepth flDepths.y\n""\n""#		if ( defined( _X360 ) )\n""		{\n""			//Get depth from the depth texture. Need to sample with the offset of (0.5, 0.5) to fix rounding errors\n""			asm {\n""				tfetch2D flDepths.x___, vScreenPos, DepthSampler, OffsetX=0.5, OffsetY=0.5, MinFilter=point, MagFilter=point, MipFilter=point\n""			};\n""\n""#			if(	!defined( REVERSE_DEPTH_ON_X360 ) )\n""				flSceneDepth = 1.0f - flSceneDepth;\n""#			endif\n""\n""			//get the sprite depth into the same range as the texture depth\n""			flSpriteDepth = fProjZ / fProjW;\n""\n""			//unproject to get at the pre-projection z. This value is much more linear than depth\n""			flDepths = vDepthBlendConstants.z / flDepths;\n""			flDepths = vDepthBlendConstants.y - flDepths;\n""\n""			flFeatheredAlpha = flSceneDepth - flSpriteDepth;\n""			flFeatheredAlpha *= vDepthBlendConstants.x;\n""			flFeatheredAlpha = saturate( flFeatheredAlpha );\n""		}\n""#		else\n""		{\n""			flSceneDepth = tex2D( DepthSampler, vScreenPos ).a;	// PC uses dest alpha of the frame buffer\n""			flSpriteDepth = SoftParticleDepth( fProjZ );\n""\n""			flFeatheredAlpha = abs(flSceneDepth - flSpriteDepth) * vDepthBlendConstants.x;\n""			flFeatheredAlpha = max( smoothstep( 0.75f, 1.0f, flSceneDepth ), flFeatheredAlpha ); //as the sprite approaches the edge of our compressed depth space, the math stops working. So as the sprite approaches the far depth, smoothly remove feathering.\n""			flFeatheredAlpha = saturate( flFeatheredAlpha );\n""		}\n""#		endif\n""\n""#undef flSceneDepth\n""#undef flSpriteDepth\n""\n""		return flFeatheredAlpha;\n""	}\n""#	else\n""	{\n""		return 1.0f;\n""	}\n""#	endif\n""}\n""\n""#endif //#ifndef COMMON_PS_FXC_H_\n""\n";