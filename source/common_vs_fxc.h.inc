const char common_vs_fxc_h[] = "//========= Copyright Valve Corporation, All rights reserved. ============//\n""//\n""// Purpose: This is where all common code for vertex shaders go.\n""//\n""// $NoKeywords: $\n""//\n""//===========================================================================//\n""\n""\n""\n""#ifndef COMMON_VS_FXC_H_\n""#define COMMON_VS_FXC_H_\n""\n""#include \"common_fxc.h\"\n""\n""// Put global skip commands here. . make sure and check that the appropriate vars are defined\n""// so these aren't used on the wrong shaders!\n""// --------------------------------------------------------------------------------\n""// Ditch all fastpath attemps if we are doing LIGHTING_PREVIEW.\n""//	SKIP: defined $LIGHTING_PREVIEW && defined $FASTPATH && $LIGHTING_PREVIEW && $FASTPATH\n""// --------------------------------------------------------------------------------\n""\n""\n""#ifndef COMPRESSED_VERTS\n""// Default to no vertex compression\n""#define COMPRESSED_VERTS 0\n""#endif\n""\n""#if ( !defined( SHADER_MODEL_VS_2_0 ) && !defined( SHADER_MODEL_VS_3_0 ) )\n""#if COMPRESSED_VERTS == 1\n""#error \"Vertex compression is only for DX9 and up!\"\n""#endif\n""#endif\n""\n""// We're testing 2 normal compression methods\n""// One compressed normals+tangents into a SHORT2 each (8 bytes total)\n""// The other compresses them together, into a single UBYTE4 (4 bytes total)\n""// FIXME: pick one or the other, compare lighting quality in important cases\n""#define COMPRESSED_NORMALS_SEPARATETANGENTS_SHORT2	0\n""#define COMPRESSED_NORMALS_COMBINEDTANGENTS_UBYTE4	1\n""//#define COMPRESSED_NORMALS_TYPE						COMPRESSED_NORMALS_SEPARATETANGENTS_SHORT2\n""#define COMPRESSED_NORMALS_TYPE					COMPRESSED_NORMALS_COMBINEDTANGENTS_UBYTE4\n""\n""\n""#define FOGTYPE_RANGE				0\n""#define FOGTYPE_HEIGHT				1\n""\n""#define COMPILE_ERROR ( 1/0; )\n""\n""// -------------------------\n""// CONSTANTS\n""// -------------------------\n""\n""#pragma def ( vs, c0, 0.0f, 1.0f, 2.0f, 0.5f )\n""\n""const float4 cConstants1				: register(c1);\n""#define cOOGamma			cConstants1.x\n""#define cOverbright			2.0f\n""#define cOneThird			cConstants1.z\n""#define cOOOverbright		( 1.0f / 2.0f )\n""\n""\n""// The g_bLightEnabled registers and g_nLightCountRegister hold the same information regarding\n""// enabling lights, but callers internal to this file tend to use the loops, while external\n""// callers will end up using the booleans\n""const bool g_bLightEnabled[4]			: register(b0);\n""										// through b3\n""\n""const int g_nLightCountRegister			: register(i0);\n""\n""\n""#define g_nLightCount					g_nLightCountRegister.x\n""\n""const float4 cEyePosWaterZ				: register(c2);\n""#define cEyePos			cEyePosWaterZ.xyz\n""\n""// Only cFlexScale.x is used\n""// It is a binary value used to switch on/off the addition of the flex delta stream\n""const float4 cFlexScale					: register( c3 );\n""\n""const float4x4 cModelViewProj			: register(c4);\n""const float4x4 cViewProj				: register(c8);\n""\n""// Used to compute projPosZ in shaders without skinning\n""// Using cModelViewProj with FastClip generates incorrect results\n""// This is just row two of the non-FastClip cModelViewProj matrix\n""const float4 cModelViewProjZ			: register(c12);\n""\n""// More constants working back from the top...\n""const float4 cViewProjZ					: register(c13);\n""\n""const float4 cFogParams					: register(c16);\n""#define cFogEndOverFogRange cFogParams.x\n""#define cFogOne cFogParams.y\n""#define cFogMaxDensity cFogParams.z\n""#define cOOFogRange cFogParams.w\n""\n""const float4x4 cViewModel				: register(c17);\n""\n""const float3 cAmbientCubeX [ 2 ] : register ( c21 ) ;\n""const float3 cAmbientCubeY [ 2 ] : register ( c23 ) ;\n""const float3 cAmbientCubeZ [ 2 ] : register ( c25 ) ;\n""\n""#if defined ( SHADER_MODEL_VS_3_0 )\n""const float4 cFlexWeights [ 512 ] : register ( c1024 ) ;\n""#endif\n""\n""struct LightInfo\n""{\n""	float4 color;						// {xyz} is color	w is light type code (see comment below)\n""	float4 dir;							// {xyz} is dir		w is light type code\n""	float4 pos;\n""	float4 spotParams;\n""	float4 atten;\n""};\n""\n""// w components of color and dir indicate light type:\n""// 1x - directional\n""// 01 - spot\n""// 00 - point\n""\n""// Four lights x 5 constants each = 20 constants\n""LightInfo cLightInfo[4]					: register(c27);\n""#define LIGHT_0_POSITION_REG					   c29\n""\n""#ifdef SHADER_MODEL_VS_1_1\n""\n""const float4 cModulationColor			: register(c37);\n""\n""#define SHADER_SPECIFIC_CONST_0 c38\n""#define SHADER_SPECIFIC_CONST_1 c39\n""#define SHADER_SPECIFIC_CONST_2 c40\n""#define SHADER_SPECIFIC_CONST_3 c41\n""#define SHADER_SPECIFIC_CONST_4 c42\n""#define SHADER_SPECIFIC_CONST_5 c43\n""#define SHADER_SPECIFIC_CONST_6 c44\n""#define SHADER_SPECIFIC_CONST_7 c45\n""#define SHADER_SPECIFIC_CONST_8 c46\n""#define SHADER_SPECIFIC_CONST_9 c47\n""#define SHADER_SPECIFIC_CONST_10 c14\n""#define SHADER_SPECIFIC_CONST_11 c15\n""\n""static const int cModel0Index = 48;\n""const float4x3 cModel[16]					: register(c48);\n""// last cmodel is c105 for dx80, c214 for dx90\n""\n""#else // DX9 shaders (vs20 and beyond)\n""\n""const float4 cModulationColor			: register( c47 );\n""\n""#define SHADER_SPECIFIC_CONST_0 c48\n""#define SHADER_SPECIFIC_CONST_1 c49\n""#define SHADER_SPECIFIC_CONST_2 c50\n""#define SHADER_SPECIFIC_CONST_3 c51\n""#define SHADER_SPECIFIC_CONST_4 c52\n""#define SHADER_SPECIFIC_CONST_5 c53\n""#define SHADER_SPECIFIC_CONST_6 c54\n""#define SHADER_SPECIFIC_CONST_7 c55\n""#define SHADER_SPECIFIC_CONST_8 c56\n""#define SHADER_SPECIFIC_CONST_9 c57\n""#define SHADER_SPECIFIC_CONST_10 c14\n""#define SHADER_SPECIFIC_CONST_11 c15\n""\n""static const int cModel0Index = 58;\n""const float4x3 cModel[53]				: register( c58 );\n""// last cmodel is c105 for dx80, c216 for dx90\n""\n""\n""#define SHADER_SPECIFIC_BOOL_CONST_0 b4\n""#define SHADER_SPECIFIC_BOOL_CONST_1 b5\n""#define SHADER_SPECIFIC_BOOL_CONST_2 b6\n""#define SHADER_SPECIFIC_BOOL_CONST_3 b7\n""#define SHADER_SPECIFIC_BOOL_CONST_4 b8\n""#define SHADER_SPECIFIC_BOOL_CONST_5 b9\n""#define SHADER_SPECIFIC_BOOL_CONST_6 b10\n""#define SHADER_SPECIFIC_BOOL_CONST_7 b11\n""#endif // vertex shader model constant packing changes\n""\n""\n""//=======================================================================================\n""// Methods to decompress vertex normals\n""//=======================================================================================\n""\n""//-----------------------------------------------------------------------------------\n""// Decompress a normal from two-component compressed format\n""// We expect this data to come from a signed SHORT2 stream in the range of -32768..32767\n""//\n""// -32678 and 0 are invalid encodings\n""// w contains the sign to use in the cross product when generating a binormal\n""void _DecompressShort2Tangent( float2 inputTangent, out float4 outputTangent )\n""{\n""	float2 ztSigns		= sign( inputTangent );				// sign bits for z and tangent (+1 or -1)\n""	float2 xyAbs		= abs(  inputTangent );				// 1..32767\n""	outputTangent.xy	= (xyAbs - 16384.0f) / 16384.0f;	// x and y\n""	outputTangent.z		= ztSigns.x * sqrt( saturate( 1.0f - dot( outputTangent.xy, outputTangent.xy ) ) );\n""	outputTangent.w		= ztSigns.y;\n""}\n""\n""//-----------------------------------------------------------------------------------\n""// Same code as _DecompressShort2Tangent, just one returns a float4, one a float3\n""void _DecompressShort2Normal( float2 inputNormal, out float3 outputNormal )\n""{\n""	float4 result;\n""	_DecompressShort2Tangent( inputNormal, result );\n""	outputNormal = result.xyz;\n""}\n""\n""//-----------------------------------------------------------------------------------\n""// Decompress normal+tangent together\n""void _DecompressShort2NormalTangent( float2 inputNormal, float2 inputTangent, out float3 outputNormal, out float4 outputTangent )\n""{\n""	// FIXME: if we end up sticking with the SHORT2 format, pack the normal and tangent into a single SHORT4 element\n""	//        (that would make unpacking normal+tangent here together much cheaper than the sum of their parts)\n""	_DecompressShort2Normal(  inputNormal,  outputNormal  );\n""	_DecompressShort2Tangent( inputTangent, outputTangent );\n""}\n""\n""//=======================================================================================\n""// Decompress a normal and tangent from four-component compressed format\n""// We expect this data to come from an unsigned UBYTE4 stream in the range of 0..255\n""// The final vTangent.w contains the sign to use in the cross product when generating a binormal\n""void _DecompressUByte4NormalTangent( float4 inputNormal,\n""									out float3 outputNormal,   // {nX, nY, nZ}\n""									out float4 outputTangent )   // {tX, tY, tZ, sign of binormal}\n""{\n""	float fOne   = 1.0f;\n""\n""	float4 ztztSignBits	= ( inputNormal - 128.0f ) < 0;						// sign bits for zs and binormal (1 or 0)  set-less-than (slt) asm instruction\n""	float4 xyxyAbs		= abs( inputNormal - 128.0f ) - ztztSignBits;		// 0..127\n""	float4 xyxySignBits	= ( xyxyAbs - 64.0f ) < 0;							// sign bits for xs and ys (1 or 0)\n""	float4 normTan		= (abs( xyxyAbs - 64.0f ) - xyxySignBits) / 63.0f;	// abs({nX, nY, tX, tY})\n""	outputNormal.xy		= normTan.xy;										// abs({nX, nY, __, __})\n""	outputTangent.xy	= normTan.zw;										// abs({tX, tY, __, __})\n""\n""	float4 xyxySigns	= 1 - 2*xyxySignBits;								// Convert sign bits to signs\n""	float4 ztztSigns	= 1 - 2*ztztSignBits;								// ( [1,0] -> [-1,+1] )\n""\n""	outputNormal.z		= 1.0f - outputNormal.x - outputNormal.y;			// Project onto x+y+z=1\n""	outputNormal.xyz	= normalize( outputNormal.xyz );					// Normalize onto unit sphere\n""	outputNormal.xy	   *= xyxySigns.xy;										// Restore x and y signs\n""	outputNormal.z	   *= ztztSigns.x;										// Restore z sign\n""\n""	outputTangent.z		= 1.0f - outputTangent.x - outputTangent.y;			// Project onto x+y+z=1\n""	outputTangent.xyz	= normalize( outputTangent.xyz );					// Normalize onto unit sphere\n""	outputTangent.xy   *= xyxySigns.zw;										// Restore x and y signs\n""	outputTangent.z	   *= ztztSigns.z;										// Restore z sign\n""	outputTangent.w		= ztztSigns.w;										// Binormal sign\n""}\n""\n""\n""//-----------------------------------------------------------------------------------\n""// Decompress just a normal from four-component compressed format (same as above)\n""// We expect this data to come from an unsigned UBYTE4 stream in the range of 0..255\n""// [ When compiled, this works out to approximately 17 asm instructions ]\n""void _DecompressUByte4Normal( float4 inputNormal,\n""							out float3 outputNormal)					// {nX, nY, nZ}\n""{\n""	float fOne			= 1.0f;\n""\n""	float2 ztSigns		= ( inputNormal.xy - 128.0f ) < 0;				// sign bits for zs and binormal (1 or 0)  set-less-than (slt) asm instruction\n""	float2 xyAbs		= abs( inputNormal.xy - 128.0f ) - ztSigns;		// 0..127\n""	float2 xySigns		= ( xyAbs -  64.0f ) < 0;						// sign bits for xs and ys (1 or 0)\n""	outputNormal.xy		= ( abs( xyAbs - 64.0f ) - xySigns ) / 63.0f;	// abs({nX, nY})\n""\n""	outputNormal.z		= 1.0f - outputNormal.x - outputNormal.y;		// Project onto x+y+z=1\n""	outputNormal.xyz	= normalize( outputNormal.xyz );				// Normalize onto unit sphere\n""\n""	outputNormal.xy	   *= lerp( fOne.xx, -fOne.xx, xySigns   );			// Restore x and y signs\n""	outputNormal.z	   *= lerp( fOne.x,  -fOne.x,  ztSigns.x );			// Restore z sign\n""}\n""\n""\n""void DecompressVertex_Normal( float4 inputNormal, out float3 outputNormal )\n""{\n""	if ( COMPRESSED_VERTS == 1 )\n""	{\n""		if ( COMPRESSED_NORMALS_TYPE == COMPRESSED_NORMALS_SEPARATETANGENTS_SHORT2 )\n""		{\n""			_DecompressShort2Normal( inputNormal.xy, outputNormal );\n""		}\n""		else // ( COMPRESSED_NORMALS_TYPE == COMPRESSED_NORMALS_COMBINEDTANGENTS_UBYTE4 )\n""		{\n""			_DecompressUByte4Normal( inputNormal, outputNormal );\n""		}\n""	}\n""	else\n""	{\n""		outputNormal = inputNormal.xyz;\n""	}\n""}\n""\n""void DecompressVertex_NormalTangent( float4 inputNormal,  float4 inputTangent, out float3 outputNormal, out float4 outputTangent )\n""{\n""	if ( COMPRESSED_VERTS == 1 )\n""	{\n""		if ( COMPRESSED_NORMALS_TYPE == COMPRESSED_NORMALS_SEPARATETANGENTS_SHORT2 )\n""		{\n""			_DecompressShort2NormalTangent( inputNormal.xy, inputTangent.xy, outputNormal, outputTangent );\n""		}\n""		else // ( COMPRESSED_NORMALS_TYPE == COMPRESSED_NORMALS_COMBINEDTANGENTS_UBYTE4 )\n""		{\n""			_DecompressUByte4NormalTangent( inputNormal, outputNormal, outputTangent );\n""		}\n""	}\n""	else\n""	{\n""		outputNormal  = inputNormal.xyz;\n""		outputTangent = inputTangent;\n""	}\n""}\n""\n""\n""#ifdef SHADER_MODEL_VS_3_0\n""\n""//-----------------------------------------------------------------------------\n""// Methods to sample morph data from a vertex texture\n""// NOTE: vMorphTargetTextureDim.x = width, cVertexTextureDim.y = height, cVertexTextureDim.z = # of float4 fields per vertex\n""// For position + normal morph for example, there will be 2 fields.\n""//-----------------------------------------------------------------------------\n""float4 SampleMorphDelta( sampler2D vt, const float3 vMorphTargetTextureDim, const float4 vMorphSubrect, const float flVertexID, const float flField )\n""{\n""	float flColumn = floor( flVertexID / vMorphSubrect.w );\n""\n""	float4 t;\n""	t.x = vMorphSubrect.x + vMorphTargetTextureDim.z * flColumn + flField + 0.5f;\n""	t.y = vMorphSubrect.y + flVertexID - flColumn * vMorphSubrect.w + 0.5f;\n""	t.xy /= vMorphTargetTextureDim.xy;	\n""	t.z = t.w = 0.f;\n""\n""	return tex2Dlod( vt, t );\n""}\n""\n""// Optimized version which reads 2 deltas\n""void SampleMorphDelta2( sampler2D vt, const float3 vMorphTargetTextureDim, const float4 vMorphSubrect, const float flVertexID, out float4 delta1, out float4 delta2 )\n""{\n""	float flColumn = floor( flVertexID / vMorphSubrect.w );\n""\n""	float4 t;\n""	t.x = vMorphSubrect.x + vMorphTargetTextureDim.z * flColumn + 0.5f;\n""	t.y = vMorphSubrect.y + flVertexID - flColumn * vMorphSubrect.w + 0.5f;\n""	t.xy /= vMorphTargetTextureDim.xy;	\n""	t.z = t.w = 0.f;\n""\n""	delta1 = tex2Dlod( vt, t );\n""	t.x += 1.0f / vMorphTargetTextureDim.x;\n""	delta2 = tex2Dlod( vt, t );\n""}\n""\n""#endif // SHADER_MODEL_VS_3_0\n""\n""\n""#if ( defined( SHADER_MODEL_VS_2_0 ) || defined( SHADER_MODEL_VS_3_0 ) )\n""\n""//-----------------------------------------------------------------------------\n""// Method to apply morphs\n""//-----------------------------------------------------------------------------\n""bool ApplyMorph( float3 vPosFlex, inout float3 vPosition )\n""{\n""	// Flexes coming in from a separate stream\n""	float3 vPosDelta = vPosFlex.xyz * cFlexScale.x;\n""	vPosition.xyz += vPosDelta;\n""	return true;\n""}\n""\n""bool ApplyMorph( float3 vPosFlex, float3 vNormalFlex, inout float3 vPosition, inout float3 vNormal )\n""{\n""	// Flexes coming in from a separate stream\n""	float3 vPosDelta = vPosFlex.xyz * cFlexScale.x;\n""	float3 vNormalDelta = vNormalFlex.xyz * cFlexScale.x;\n""	vPosition.xyz += vPosDelta;\n""	vNormal       += vNormalDelta;\n""	return true;\n""}\n""\n""bool ApplyMorph( float3 vPosFlex, float3 vNormalFlex, \n""	inout float3 vPosition, inout float3 vNormal, inout float3 vTangent )\n""{\n""	// Flexes coming in from a separate stream\n""	float3 vPosDelta = vPosFlex.xyz * cFlexScale.x;\n""	float3 vNormalDelta = vNormalFlex.xyz * cFlexScale.x;\n""	vPosition.xyz += vPosDelta;\n""	vNormal       += vNormalDelta;\n""	vTangent.xyz  += vNormalDelta;\n""	return true;\n""}\n""\n""bool ApplyMorph( float4 vPosFlex, float3 vNormalFlex, \n""	inout float3 vPosition, inout float3 vNormal, inout float3 vTangent, out float flWrinkle )\n""{\n""	// Flexes coming in from a separate stream\n""	float3 vPosDelta = vPosFlex.xyz * cFlexScale.x;\n""	float3 vNormalDelta = vNormalFlex.xyz * cFlexScale.x;\n""	flWrinkle = vPosFlex.w * cFlexScale.y;\n""	vPosition.xyz += vPosDelta;\n""	vNormal       += vNormalDelta;\n""	vTangent.xyz  += vNormalDelta;\n""	return true;\n""}\n""\n""#endif // defined( SHADER_MODEL_VS_2_0 ) || defined( SHADER_MODEL_VS_3_0 )\n""\n""\n""#ifdef SHADER_MODEL_VS_3_0\n""\n""bool ApplyMorph( sampler2D morphSampler, const float3 vMorphTargetTextureDim, const float4 vMorphSubrect, \n""				const float flVertexID, const float3 vMorphTexCoord,\n""				inout float3 vPosition )\n""{\n""#if MORPHING\n""\n""#if !DECAL\n""	// Flexes coming in from a separate stream\n""	float4 vPosDelta = SampleMorphDelta( morphSampler, vMorphTargetTextureDim, vMorphSubrect, flVertexID, 0 );\n""	vPosition	+= vPosDelta.xyz;\n""#else\n""	float4 t = float4( vMorphTexCoord.x, vMorphTexCoord.y, 0.0f, 0.0f );\n""	float3 vPosDelta = tex2Dlod( morphSampler, t );\n""	vPosition	+= vPosDelta.xyz * vMorphTexCoord.z;\n""#endif // DECAL\n""\n""	return true;\n""\n""#else // !MORPHING\n""	return false;\n""#endif\n""}\n"" \n""bool ApplyMorph( sampler2D morphSampler, const float3 vMorphTargetTextureDim, const float4 vMorphSubrect, \n""				const float flVertexID, const float3 vMorphTexCoord, \n""				inout float3 vPosition, inout float3 vNormal )\n""{\n""#if MORPHING\n""\n""#if !DECAL\n""	float4 vPosDelta, vNormalDelta;\n""	SampleMorphDelta2( morphSampler, vMorphTargetTextureDim, vMorphSubrect, flVertexID, vPosDelta, vNormalDelta );\n""	vPosition	+= vPosDelta.xyz;\n""	vNormal		+= vNormalDelta.xyz;\n""#else\n""	float4 t = float4( vMorphTexCoord.x, vMorphTexCoord.y, 0.0f, 0.0f );\n""	float3 vPosDelta = tex2Dlod( morphSampler, t );\n""	t.x += 1.0f / vMorphTargetTextureDim.x;\n""	float3 vNormalDelta = tex2Dlod( morphSampler, t );\n""	vPosition	+= vPosDelta.xyz * vMorphTexCoord.z;\n""	vNormal		+= vNormalDelta.xyz * vMorphTexCoord.z;\n""#endif // DECAL\n""\n""	return true;\n""\n""#else // !MORPHING\n""	return false;\n""#endif\n""}\n""\n""bool ApplyMorph( sampler2D morphSampler, const float3 vMorphTargetTextureDim, const float4 vMorphSubrect, \n""				const float flVertexID, const float3 vMorphTexCoord, \n""				inout float3 vPosition, inout float3 vNormal, inout float3 vTangent )\n""{\n""#if MORPHING\n""\n""#if !DECAL\n""	float4 vPosDelta, vNormalDelta;\n""	SampleMorphDelta2( morphSampler, vMorphTargetTextureDim, vMorphSubrect, flVertexID, vPosDelta, vNormalDelta );\n""	vPosition	+= vPosDelta.xyz;\n""	vNormal		+= vNormalDelta.xyz;\n""	vTangent	+= vNormalDelta.xyz;\n""#else\n""	float4 t = float4( vMorphTexCoord.x, vMorphTexCoord.y, 0.0f, 0.0f );\n""	float3 vPosDelta = tex2Dlod( morphSampler, t );\n""	t.x += 1.0f / vMorphTargetTextureDim.x;\n""	float3 vNormalDelta = tex2Dlod( morphSampler, t );\n""	vPosition	+= vPosDelta.xyz * vMorphTexCoord.z;\n""	vNormal		+= vNormalDelta.xyz * vMorphTexCoord.z;\n""	vTangent	+= vNormalDelta.xyz * vMorphTexCoord.z;\n""#endif // DECAL\n""\n""	return true;\n""\n""#else // MORPHING\n""\n""	return false;\n""#endif\n""}\n""\n""bool ApplyMorph( sampler2D morphSampler, const float3 vMorphTargetTextureDim, const float4 vMorphSubrect,\n""	const float flVertexID, const float3 vMorphTexCoord,\n""	inout float3 vPosition, inout float3 vNormal, inout float3 vTangent, out float flWrinkle )\n""{\n""#if MORPHING\n""\n""#if !DECAL\n""	float4 vPosDelta, vNormalDelta;\n""	SampleMorphDelta2( morphSampler, vMorphTargetTextureDim, vMorphSubrect, flVertexID, vPosDelta, vNormalDelta );\n""	vPosition	+= vPosDelta.xyz;\n""	vNormal		+= vNormalDelta.xyz;\n""	vTangent	+= vNormalDelta.xyz;\n""	flWrinkle = vPosDelta.w;\n""#else\n""	float4 t = float4( vMorphTexCoord.x, vMorphTexCoord.y, 0.0f, 0.0f );\n""	float4 vPosDelta = tex2Dlod( morphSampler, t );\n""	t.x += 1.0f / vMorphTargetTextureDim.x;\n""	float3 vNormalDelta = tex2Dlod( morphSampler, t );\n""\n""	vPosition	+= vPosDelta.xyz * vMorphTexCoord.z;\n""	vNormal		+= vNormalDelta.xyz * vMorphTexCoord.z;\n""	vTangent	+= vNormalDelta.xyz * vMorphTexCoord.z;\n""	flWrinkle	= vPosDelta.w * vMorphTexCoord.z;\n""#endif // DECAL\n""\n""	return true;\n""\n""#else // MORPHING\n""\n""	flWrinkle = 0.0f;\n""	return false;\n""\n""#endif\n""}\n""\n""#endif   // SHADER_MODEL_VS_3_0\n""\n""\n""float RangeFog( const float3 projPos )\n""{\n""	return max( cFogMaxDensity, ( -projPos.z * cOOFogRange + cFogEndOverFogRange ) );\n""}\n""\n""float WaterFog( const float3 worldPos, const float3 projPos )\n""{\n""	float4 tmp;\n""	\n""	tmp.xy = cEyePosWaterZ.wz - worldPos.z;\n""\n""	// tmp.x is the distance from the water surface to the vert\n""	// tmp.y is the distance from the eye position to the vert\n""\n""	// if $tmp.x < 0, then set it to 0\n""	// This is the equivalent of moving the vert to the water surface if it's above the water surface\n""	\n""	tmp.x = max( 0.0f, tmp.x );\n""\n""	// $tmp.w = $tmp.x / $tmp.y\n""	tmp.w = tmp.x / tmp.y;\n""\n""	tmp.w *= projPos.z;\n""\n""	// $tmp.w is now the distance that we see through water.\n""\n""	return max( cFogMaxDensity, ( -tmp.w * cOOFogRange + cFogOne ) );\n""}\n""\n""float CalcFog( const float3 worldPos, const float3 projPos, const int fogType )\n""{\n""#if defined( _X360 )\n""	// 360 only does pixel fog\n""	return 1.0f;\n""#endif\n""\n""	if( fogType == FOGTYPE_RANGE )\n""	{\n""		return RangeFog( projPos );\n""	}\n""	else\n""	{\n""#if SHADERMODEL_VS_2_0 == 1\n""		// We do this work in the pixel shader in dx9, so don't do any fog here.\n""		return 1.0f;\n""#else\n""		return WaterFog( worldPos, projPos );\n""#endif\n""	}\n""}\n""\n""float CalcFog( const float3 worldPos, const float3 projPos, const bool bWaterFog )\n""{\n""#if defined( _X360 )\n""	// 360 only does pixel fog\n""	return 1.0f;\n""#endif\n""\n""	float flFog;\n""	if( !bWaterFog )\n""	{\n""		flFog = RangeFog( projPos );\n""	}\n""	else\n""	{\n""#if SHADERMODEL_VS_2_0 == 1\n""		// We do this work in the pixel shader in dx9, so don't do any fog here.\n""		flFog = 1.0f;\n""#else\n""		flFog = WaterFog( worldPos, projPos );\n""#endif\n""	}\n""\n""	return flFog;\n""}\n""\n""float4 DecompressBoneWeights( const float4 weights )\n""{\n""	float4 result = weights;\n""\n""	if ( COMPRESSED_VERTS )\n""	{\n""		// Decompress from SHORT2 to float. In our case, [-1, +32767] -> [0, +1]\n""		// NOTE: we add 1 here so we can divide by 32768 - which is exact (divide by 32767 is not).\n""		//       This avoids cracking between meshes with different numbers of bone weights.\n""		//       We use SHORT2 instead of SHORT2N for a similar reason - the GPU's conversion\n""		//       from [-32768,+32767] to [-1,+1] is imprecise in the same way.\n""		result += 1;\n""		result /= 32768;\n""	}\n""\n""	return result;\n""}\n""\n""void SkinPosition( bool bSkinning, const float4 modelPos, \n""                   const float4 boneWeights, float4 fBoneIndices,\n""				   out float3 worldPos )\n""{\n""#if !defined( _X360 )\n""	int3 boneIndices = D3DCOLORtoUBYTE4( fBoneIndices );\n""#else\n""	int3 boneIndices = fBoneIndices;\n""#endif\n""\n""	// Needed for invariance issues caused by multipass rendering\n""#if defined( _X360 )\n""	[isolate] \n""#endif\n""	{ \n""		if ( !bSkinning )\n""		{\n""			worldPos = mul4x3( modelPos, cModel[0] );\n""		}\n""		else // skinning - always three bones\n""		{\n""			float4x3 mat1 = cModel[boneIndices[0]];\n""			float4x3 mat2 = cModel[boneIndices[1]];\n""			float4x3 mat3 = cModel[boneIndices[2]];\n""\n""			float3 weights = DecompressBoneWeights( boneWeights ).xyz;\n""			weights[2] = 1 - (weights[0] + weights[1]);\n""\n""			float4x3 blendMatrix = mat1 * weights[0] + mat2 * weights[1] + mat3 * weights[2];\n""			worldPos = mul4x3( modelPos, blendMatrix );\n""		}\n""	}\n""}\n""\n""void SkinPositionAndNormal( bool bSkinning, const float4 modelPos, const float3 modelNormal,\n""                            const float4 boneWeights, float4 fBoneIndices,\n""						    out float3 worldPos, out float3 worldNormal )\n""{\n""	// Needed for invariance issues caused by multipass rendering\n""#if defined( _X360 )\n""	[isolate] \n""#endif\n""	{ \n""\n""#if !defined( _X360 )\n""		int3 boneIndices = D3DCOLORtoUBYTE4( fBoneIndices );\n""#else\n""		int3 boneIndices = fBoneIndices;\n""#endif\n""\n""		if ( !bSkinning )\n""		{\n""			worldPos = mul4x3( modelPos, cModel[0] );\n""			worldNormal = mul3x3( modelNormal, ( const float3x3 )cModel[0] );\n""		}\n""		else // skinning - always three bones\n""		{\n""			float4x3 mat1 = cModel[boneIndices[0]];\n""			float4x3 mat2 = cModel[boneIndices[1]];\n""			float4x3 mat3 = cModel[boneIndices[2]];\n""\n""			float3 weights = DecompressBoneWeights( boneWeights ).xyz;\n""			weights[2] = 1 - (weights[0] + weights[1]);\n""\n""			float4x3 blendMatrix = mat1 * weights[0] + mat2 * weights[1] + mat3 * weights[2];\n""			worldPos = mul4x3( modelPos, blendMatrix );\n""			worldNormal = mul3x3( modelNormal, ( float3x3 )blendMatrix );\n""		}\n""\n""	} // end [isolate]\n""}\n""\n""// Is it worth keeping SkinPosition and SkinPositionAndNormal around since the optimizer\n""// gets rid of anything that isn't used?\n""void SkinPositionNormalAndTangentSpace( \n""							bool bSkinning,\n""						    const float4 modelPos, const float3 modelNormal, \n""							const float4 modelTangentS,\n""                            const float4 boneWeights, float4 fBoneIndices,\n""						    out float3 worldPos, out float3 worldNormal, \n""							out float3 worldTangentS, out float3 worldTangentT )\n""{\n""#if !defined( _X360 )\n""	int3 boneIndices = D3DCOLORtoUBYTE4( fBoneIndices );\n""#else\n""	int3 boneIndices = fBoneIndices;\n""#endif\n""\n""	// Needed for invariance issues caused by multipass rendering\n""#if defined( _X360 )\n""	[isolate] \n""#endif\n""	{ \n""		if ( !bSkinning )\n""		{\n""			worldPos = mul4x3( modelPos, cModel[0] );\n""			worldNormal = mul3x3( modelNormal, ( const float3x3 )cModel[0] );\n""			worldTangentS = mul3x3( ( float3 )modelTangentS, ( const float3x3 )cModel[0] );\n""		}\n""		else // skinning - always three bones\n""		{\n""			float4x3 mat1 = cModel[boneIndices[0]];\n""			float4x3 mat2 = cModel[boneIndices[1]];\n""			float4x3 mat3 = cModel[boneIndices[2]];\n""\n""			float3 weights = DecompressBoneWeights( boneWeights ).xyz;\n""			weights[2] = 1 - (weights[0] + weights[1]);\n""\n""			float4x3 blendMatrix = mat1 * weights[0] + mat2 * weights[1] + mat3 * weights[2];\n""			worldPos = mul4x3( modelPos, blendMatrix );\n""			worldNormal = mul3x3( modelNormal, ( const float3x3 )blendMatrix );\n""			worldTangentS = mul3x3( ( float3 )modelTangentS, ( const float3x3 )blendMatrix );\n""		}\n""		worldTangentT = cross( worldNormal, worldTangentS ) * modelTangentS.w;\n""	}\n""}\n""\n""\n""//-----------------------------------------------------------------------------\n""// Lighting helper functions\n""//-----------------------------------------------------------------------------\n""\n""float3 AmbientLight( const float3 worldNormal )\n""{\n""	float3 nSquared = worldNormal * worldNormal;\n""	int3 isNegative = ( worldNormal < 0.0 );\n""	float3 linearColor;\n""	linearColor = nSquared.x * cAmbientCubeX[isNegative.x] +\n""	              nSquared.y * cAmbientCubeY[isNegative.y] +\n""	              nSquared.z * cAmbientCubeZ[isNegative.z];\n""	return linearColor;\n""}\n""\n""// The following \"internal\" routines are called \"privately\" by other routines in this file which\n""// handle the particular flavor of vs20 control flow appropriate to the original caller\n""float VertexAttenInternal( const float3 worldPos, int lightNum )\n""{\n""	float result = 0.0f;\n""\n""	// Get light direction\n""	float3 lightDir = cLightInfo[lightNum].pos - worldPos;\n""\n""	// Get light distance squared.\n""	float lightDistSquared = dot( lightDir, lightDir );\n""\n""	// Get 1/lightDistance\n""	float ooLightDist = rsqrt( lightDistSquared );\n""\n""	// Normalize light direction\n""	lightDir *= ooLightDist;\n""\n""	float3 vDist;\n""#	if defined( _X360 )\n""	{\n""		//X360 dynamic compile hits an internal compiler error using dst(), this is the breakdown of how dst() works from the 360 docs.\n""		vDist.x = 1;\n""		vDist.y = lightDistSquared * ooLightDist;\n""		vDist.z = lightDistSquared;\n""		//flDist.w = ooLightDist;\n""	}\n""#	else\n""	{\n""		vDist = dst( lightDistSquared, ooLightDist );\n""	}\n""#	endif\n""\n""	float flDistanceAtten = 1.0f / dot( cLightInfo[lightNum].atten.xyz, vDist );\n""\n""	// Spot attenuation\n""	float flCosTheta = dot( cLightInfo[lightNum].dir.xyz, -lightDir );\n""	float flSpotAtten = (flCosTheta - cLightInfo[lightNum].spotParams.z) * cLightInfo[lightNum].spotParams.w;\n""	flSpotAtten = max( 0.0001f, flSpotAtten );\n""	flSpotAtten = pow( flSpotAtten, cLightInfo[lightNum].spotParams.x );\n""	flSpotAtten = saturate( flSpotAtten );\n""\n""	// Select between point and spot\n""	float flAtten = lerp( flDistanceAtten, flDistanceAtten * flSpotAtten, cLightInfo[lightNum].dir.w );\n""\n""	// Select between above and directional (no attenuation)\n""	result = lerp( flAtten, 1.0f, cLightInfo[lightNum].color.w );\n""\n""	return result;\n""}\n""\n""float CosineTermInternal( const float3 worldPos, const float3 worldNormal, int lightNum, bool bHalfLambert )\n""{\n""	// Calculate light direction assuming this is a point or spot\n""	float3 lightDir = normalize( cLightInfo[lightNum].pos - worldPos );\n""\n""	// Select the above direction or the one in the structure, based upon light type\n""	lightDir = lerp( lightDir, -cLightInfo[lightNum].dir, cLightInfo[lightNum].color.w );\n""\n""	// compute N dot L\n""	float NDotL = dot( worldNormal, lightDir );\n""\n""	if ( !bHalfLambert )\n""	{\n""		NDotL = max( 0.0f, NDotL );\n""	}\n""	else	// Half-Lambert\n""	{\n""		NDotL = NDotL * 0.5 + 0.5;\n""		NDotL = NDotL * NDotL;\n""	}\n""	return NDotL;\n""}\n""\n""// This routine uses booleans to do early-outs and is meant to be called by routines OUTSIDE of this file\n""float GetVertexAttenForLight( const float3 worldPos, int lightNum, bool bUseStaticControlFlow )\n""{\n""	float result = 0.0f;\n""\n""	// Direct3D uses static control flow but OpenGL currently does not\n""	if ( bUseStaticControlFlow )\n""	{\n""		if ( g_bLightEnabled[lightNum] )\n""		{\n""			result = VertexAttenInternal( worldPos, lightNum );\n""		}\n""	}\n""	else // OpenGL non-static-control-flow path\n""	{\n""		result = VertexAttenInternal( worldPos, lightNum );\n""	}\n""\n""	return result;\n""}\n""\n""float3 DoLightInternal( const float3 worldPos, const float3 worldNormal, int lightNum, bool bHalfLambert )\n""{\n""	return cLightInfo[lightNum].color *\n""		CosineTermInternal( worldPos, worldNormal, lightNum, bHalfLambert ) *\n""		VertexAttenInternal( worldPos, lightNum );\n""}\n""\n""float3 DoLighting( const float3 worldPos, const float3 worldNormal,\n""				   const float3 staticLightingColor, const bool bStaticLight,\n""				   const bool bDynamicLight, bool bHalfLambert )\n""{\n""	float3 linearColor = float3( 0.0f, 0.0f, 0.0f );\n""\n""	if( bStaticLight )			// Static light\n""	{\n""		float3 col = staticLightingColor * cOverbright;\n""#if defined ( _X360 )\n""		linearColor += col * col;\n""#else\n""		linearColor += GammaToLinear( col );\n""#endif\n""	}\n""\n""	if( bDynamicLight )			// Dynamic light\n""	{\n""		for (int i = 0; i < g_nLightCount; i++)\n""		{\n""			linearColor += DoLightInternal( worldPos, worldNormal, i, bHalfLambert );\n""		}		\n""	}\n""\n""	if( bDynamicLight )\n""	{\n""		linearColor += AmbientLight( worldNormal ); //ambient light is already remapped\n""	}\n""\n""	return linearColor;\n""}\n""\n""float3 DoLightingUnrolled( const float3 worldPos, const float3 worldNormal,\n""				  const float3 staticLightingColor, const bool bStaticLight,\n""				  const bool bDynamicLight, bool bHalfLambert, const int nNumLights )\n""{\n""	float3 linearColor = float3( 0.0f, 0.0f, 0.0f );\n""\n""	if( bStaticLight )			// Static light\n""	{\n""		linearColor += GammaToLinear( staticLightingColor * cOverbright );\n""	}\n""\n""	if( bDynamicLight )			// Ambient light\n""	{\n""		if ( nNumLights >= 1 )\n""			linearColor += DoLightInternal( worldPos, worldNormal, 0, bHalfLambert );\n""		if ( nNumLights >= 2 )\n""			linearColor += DoLightInternal( worldPos, worldNormal, 1, bHalfLambert );\n""		if ( nNumLights >= 3 )\n""			linearColor += DoLightInternal( worldPos, worldNormal, 2, bHalfLambert );\n""		if ( nNumLights >= 4 )\n""			linearColor += DoLightInternal( worldPos, worldNormal, 3, bHalfLambert );\n""	}\n""\n""	if( bDynamicLight )\n""	{\n""		linearColor += AmbientLight( worldNormal ); //ambient light is already remapped\n""	}\n""\n""	return linearColor;\n""}\n""\n""int4 FloatToInt( in float4 floats )\n""{\n""	return D3DCOLORtoUBYTE4( floats.zyxw / 255.001953125 );\n""}\n""\n""float2 ComputeSphereMapTexCoords( in float3 reflectionVector )\n""{\n""	// transform reflection vector into view space\n""	reflectionVector = mul( reflectionVector, ( float3x3 )cViewModel );\n""\n""	// generate <rx ry rz+1>\n""	float3 tmp = float3( reflectionVector.x, reflectionVector.y, reflectionVector.z + 1.0f );\n""\n""	// find 1 / len\n""	float ooLen = dot( tmp, tmp );\n""	ooLen = 1.0f / sqrt( ooLen );\n""\n""	// tmp = tmp/|tmp| + 1\n""	tmp.xy = ooLen * tmp.xy + 1.0f;\n""\n""	return tmp.xy * 0.5f;\n""}\n""\n""\n""#define DEFORMATION_CLAMP_TO_BOX_IN_WORLDSPACE 1\n""							// minxyz.minsoftness / maxxyz.maxsoftness\n""float3 ApplyDeformation( float3 worldpos, int deftype, float4 defparms0, float4 defparms1,\n""						 float4 defparms2, float4 defparms3 )\n""{\n""	float3 ret = worldpos;\n""	if ( deftype == DEFORMATION_CLAMP_TO_BOX_IN_WORLDSPACE )\n""	{\n""		ret=max( ret, defparms2.xyz );\n""		ret=min( ret, defparms3.xyz );\n""	}\n""\n""	return ret;\n""}\n""\n""\n""#endif //#ifndef COMMON_VS_FXC_H_\n""\n";