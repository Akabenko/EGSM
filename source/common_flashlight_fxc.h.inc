const char common_flashlight_fxc_h[] = "//========= Copyright Valve Corporation, All rights reserved. ============//\n""//\n""// Purpose: Common pixel shader code specific to flashlights\n""//\n""// $NoKeywords: $\n""//\n""//=============================================================================//\n""#ifndef COMMON_FLASHLIGHT_FXC_H_\n""#define COMMON_FLASHLIGHT_FXC_H_\n""\n""#include \"common_ps_fxc.h\"\n""\n""\n""// JasonM - TODO: remove this simpleton version\n""float DoShadow( sampler DepthSampler, float4 texCoord )\n""{\n""	const float g_flShadowBias = 0.0005f;\n""	float2 uoffset = float2( 0.5f/512.f, 0.0f );\n""	float2 voffset = float2( 0.0f, 0.5f/512.f );\n""	float3 projTexCoord = texCoord.xyz / texCoord.w;\n""	float4 flashlightDepth = float4(	tex2D( DepthSampler, projTexCoord + uoffset + voffset ).x,\n""										tex2D( DepthSampler, projTexCoord + uoffset - voffset ).x,\n""										tex2D( DepthSampler, projTexCoord - uoffset + voffset ).x,\n""										tex2D( DepthSampler, projTexCoord - uoffset - voffset ).x	);\n""\n""#	if ( defined( REVERSE_DEPTH_ON_X360 ) )\n""	{\n""		flashlightDepth = 1.0f - flashlightDepth;\n""	}\n""#	endif\n""\n""	float shadowed = 0.0f;\n""	float z = texCoord.z/texCoord.w;\n""	float4 dz = float4(z,z,z,z) - (flashlightDepth + float4( g_flShadowBias, g_flShadowBias, g_flShadowBias, g_flShadowBias));\n""	float4 shadow = float4(0.25f,0.25f,0.25f,0.25f);\n""\n""	if( dz.x <= 0.0f )\n""		shadowed += shadow.x;\n""	if( dz.y <= 0.0f )\n""		shadowed += shadow.y;\n""	if( dz.z <= 0.0f )\n""		shadowed += shadow.z;\n""	if( dz.w <= 0.0f )\n""		shadowed += shadow.w;\n""\n""	return shadowed;\n""}\n""\n""\n""float DoShadowNvidiaRAWZOneTap( sampler DepthSampler, const float4 shadowMapPos )\n""{\n""	float ooW = 1.0f / shadowMapPos.w;								// 1 / w\n""	float3 shadowMapCenter_objDepth = shadowMapPos.xyz * ooW;		// Do both projections at once\n""\n""	float2 shadowMapCenter = shadowMapCenter_objDepth.xy;			// Center of shadow filter\n""	float objDepth = shadowMapCenter_objDepth.z;					// Object depth in shadow space\n""\n""	float fDepth = dot(tex2D(DepthSampler, shadowMapCenter).arg, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5));\n""\n""	return fDepth > objDepth;\n""}\n""\n""\n""float DoShadowNvidiaRAWZ( sampler DepthSampler, const float4 shadowMapPos )\n""{\n""	float fE = 1.0f / 512.0f;	 // Epsilon\n""\n""	float ooW = 1.0f / shadowMapPos.w;								// 1 / w\n""	float3 shadowMapCenter_objDepth = shadowMapPos.xyz * ooW;		// Do both projections at once\n""\n""	float2 shadowMapCenter = shadowMapCenter_objDepth.xy;			// Center of shadow filter\n""	float objDepth = shadowMapCenter_objDepth.z;					// Object depth in shadow space\n""\n""	float4 vDepths;\n""	vDepths.x = dot(tex2D(DepthSampler, shadowMapCenter + float2(  fE,  fE )).arg, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5));\n""	vDepths.y = dot(tex2D(DepthSampler, shadowMapCenter + float2( -fE,  fE )).arg, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5));\n""	vDepths.z = dot(tex2D(DepthSampler, shadowMapCenter + float2(  fE, -fE )).arg, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5));\n""	vDepths.w = dot(tex2D(DepthSampler, shadowMapCenter + float2( -fE, -fE )).arg, float3(0.996093809371817670572857294849, 0.0038909914428586627756752238080039, 1.5199185323666651467481343000015e-5));\n""\n""	return dot(vDepths > objDepth.xxxx, float4(0.25, 0.25, 0.25, 0.25));\n""}\n""\n""\n""float DoShadowNvidiaCheap( sampler DepthSampler, const float4 shadowMapPos )\n""{\n""	float fTexelEpsilon = 1.0f / 1024.0f;\n""\n""	float ooW = 1.0f / shadowMapPos.w;								// 1 / w\n""	float3 shadowMapCenter_objDepth = shadowMapPos.xyz * ooW;		// Do both projections at once\n""\n""	float2 shadowMapCenter = shadowMapCenter_objDepth.xy;			// Center of shadow filter\n""	float objDepth = shadowMapCenter_objDepth.z;					// Object depth in shadow space\n""\n""	float4 vTaps;\n""	vTaps.x = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTexelEpsilon,  fTexelEpsilon), objDepth, 1 ) ).x;\n""	vTaps.y = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTexelEpsilon,  fTexelEpsilon), objDepth, 1 ) ).x;\n""	vTaps.z = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTexelEpsilon, -fTexelEpsilon), objDepth, 1 ) ).x;\n""	vTaps.w = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTexelEpsilon, -fTexelEpsilon), objDepth, 1 ) ).x;\n""\n""	return dot(vTaps, float4(0.25, 0.25, 0.25, 0.25));\n""}\n""\n""float DoShadowNvidiaPCF3x3Box( sampler DepthSampler, const float4 shadowMapPos )\n""{\n""	float fTexelEpsilon = 1.0f / 1024.0f;\n""\n""	float ooW = 1.0f / shadowMapPos.w;								// 1 / w\n""	float3 shadowMapCenter_objDepth = shadowMapPos.xyz * ooW;		// Do both projections at once\n""\n""	float2 shadowMapCenter = shadowMapCenter_objDepth.xy;			// Center of shadow filter\n""	float objDepth = shadowMapCenter_objDepth.z;					// Object depth in shadow space\n""\n""	float4 vOneTaps;\n""	vOneTaps.x = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTexelEpsilon,  fTexelEpsilon ), objDepth, 1 ) ).x;\n""	vOneTaps.y = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTexelEpsilon,  fTexelEpsilon ), objDepth, 1 ) ).x;\n""	vOneTaps.z = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTexelEpsilon, -fTexelEpsilon ), objDepth, 1 ) ).x;\n""	vOneTaps.w = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTexelEpsilon, -fTexelEpsilon ), objDepth, 1 ) ).x;\n""	float flOneTaps = dot( vOneTaps, float4(1.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f));\n""\n""	float4 vTwoTaps;\n""	vTwoTaps.x = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTexelEpsilon,  0 ), objDepth, 1 ) ).x;\n""	vTwoTaps.y = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTexelEpsilon,  0 ), objDepth, 1 ) ).x;\n""	vTwoTaps.z = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  0, -fTexelEpsilon ), objDepth, 1 ) ).x;\n""	vTwoTaps.w = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  0, -fTexelEpsilon ), objDepth, 1 ) ).x;\n""	float flTwoTaps = dot( vTwoTaps, float4(1.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f));\n""\n""	float flCenterTap = tex2Dproj( DepthSampler, float4( shadowMapCenter, objDepth, 1 ) ).x * (1.0f / 9.0f);\n""\n""	// Sum all 9 Taps\n""	return flOneTaps + flTwoTaps + flCenterTap;\n""}\n""\n""\n""//\n""//	1	4	7	4	1\n""//	4	20	33	20	4\n""//	7	33	55	33	7\n""//	4	20	33	20	4\n""//	1	4	7	4	1\n""//\n""float DoShadowNvidiaPCF5x5Gaussian( sampler DepthSampler, const float4 shadowMapPos )\n""{\n""	float fEpsilon    = 1.0f / 512.0f;\n""	float fTwoEpsilon = 2.0f * fEpsilon;\n""\n""	float ooW = 1.0f / shadowMapPos.w;								// 1 / w\n""	float3 shadowMapCenter_objDepth = shadowMapPos.xyz * ooW;		// Do both projections at once\n""\n""	float2 shadowMapCenter = shadowMapCenter_objDepth.xy;			// Center of shadow filter\n""	float objDepth = shadowMapCenter_objDepth.z;					// Object depth in shadow space\n""\n""	float4 vOneTaps;\n""	vOneTaps.x = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTwoEpsilon,  fTwoEpsilon ), objDepth, 1 ) ).x;\n""	vOneTaps.y = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTwoEpsilon,  fTwoEpsilon ), objDepth, 1 ) ).x;\n""	vOneTaps.z = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTwoEpsilon, -fTwoEpsilon ), objDepth, 1 ) ).x;\n""	vOneTaps.w = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTwoEpsilon, -fTwoEpsilon ), objDepth, 1 ) ).x;\n""	float flOneTaps = dot( vOneTaps, float4(1.0f / 331.0f, 1.0f / 331.0f, 1.0f / 331.0f, 1.0f / 331.0f));\n""\n""	float4 vSevenTaps;\n""	vSevenTaps.x = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTwoEpsilon,  0 ), objDepth, 1 ) ).x;\n""	vSevenTaps.y = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTwoEpsilon,  0 ), objDepth, 1 ) ).x;\n""	vSevenTaps.z = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  0, -fTwoEpsilon ), objDepth, 1 ) ).x;\n""	vSevenTaps.w = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  0, -fTwoEpsilon ), objDepth, 1 ) ).x;\n""	float flSevenTaps = dot( vSevenTaps, float4( 7.0f / 331.0f, 7.0f / 331.0f, 7.0f / 331.0f, 7.0f / 331.0f ) );\n""\n""	float4 vFourTapsA, vFourTapsB;\n""	vFourTapsA.x = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTwoEpsilon,  fEpsilon    ), objDepth, 1 ) ).x;\n""	vFourTapsA.y = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fEpsilon,     fTwoEpsilon ), objDepth, 1 ) ).x;\n""	vFourTapsA.z = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fEpsilon,     fTwoEpsilon ), objDepth, 1 ) ).x;\n""	vFourTapsA.w = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTwoEpsilon,  fEpsilon    ), objDepth, 1 ) ).x;\n""	vFourTapsB.x = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fTwoEpsilon, -fEpsilon    ), objDepth, 1 ) ).x;\n""	vFourTapsB.y = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fEpsilon,    -fTwoEpsilon ), objDepth, 1 ) ).x;\n""	vFourTapsB.z = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fEpsilon,    -fTwoEpsilon ), objDepth, 1 ) ).x;\n""	vFourTapsB.w = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fTwoEpsilon, -fEpsilon    ), objDepth, 1 ) ).x;\n""	float flFourTapsA = dot( vFourTapsA, float4( 4.0f / 331.0f, 4.0f / 331.0f, 4.0f / 331.0f, 4.0f / 331.0f ) );\n""	float flFourTapsB = dot( vFourTapsB, float4( 4.0f / 331.0f, 4.0f / 331.0f, 4.0f / 331.0f, 4.0f / 331.0f ) );\n""\n""	float4 v20Taps;\n""	v20Taps.x = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fEpsilon,  fEpsilon ), objDepth, 1 ) ).x;\n""	v20Taps.y = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fEpsilon,  fEpsilon ), objDepth, 1 ) ).x;\n""	v20Taps.z = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fEpsilon, -fEpsilon ), objDepth, 1 ) ).x;\n""	v20Taps.w = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fEpsilon, -fEpsilon ), objDepth, 1 ) ).x;\n""	float fl20Taps = dot( v20Taps, float4(20.0f / 331.0f, 20.0f / 331.0f, 20.0f / 331.0f, 20.0f / 331.0f));\n""\n""	float4 v33Taps;\n""	v33Taps.x = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  fEpsilon,  0 ), objDepth, 1 ) ).x;\n""	v33Taps.y = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2( -fEpsilon,  0 ), objDepth, 1 ) ).x;\n""	v33Taps.z = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  0, -fEpsilon ), objDepth, 1 ) ).x;\n""	v33Taps.w = tex2Dproj( DepthSampler, float4( shadowMapCenter + float2(  0, -fEpsilon ), objDepth, 1 ) ).x;\n""	float fl33Taps = dot( v33Taps, float4(33.0f / 331.0f, 33.0f / 331.0f, 33.0f / 331.0f, 33.0f / 331.0f));\n""\n""	float flCenterTap = tex2Dproj( DepthSampler, float4( shadowMapCenter, objDepth, 1 ) ).x * (55.0f / 331.0f);\n""\n""	// Sum all 25 Taps\n""	return flOneTaps + flSevenTaps + +flFourTapsA + flFourTapsB + fl20Taps + fl33Taps + flCenterTap;\n""}\n""\n""\n""float DoShadowATICheap( sampler DepthSampler, const float4 shadowMapPos )\n""{\n""    float2 shadowMapCenter = shadowMapPos.xy/shadowMapPos.w;\n""	float objDepth = shadowMapPos.z / shadowMapPos.w;\n""	float fSampleDepth = tex2D( DepthSampler, shadowMapCenter ).x;\n""\n""	objDepth = min( objDepth, 0.99999 ); //HACKHACK: On 360, surfaces at or past the far flashlight plane have an abrupt cutoff. This is temp until a smooth falloff is implemented\n""\n""	return fSampleDepth > objDepth;\n""}\n""\n""\n""// Poisson disc, randomly rotated at different UVs\n""float DoShadowPoisson16Sample( sampler DepthSampler, sampler RandomRotationSampler, const float3 vProjCoords, const float2 vScreenPos, const float4 vShadowTweaks, bool bNvidiaHardwarePCF, bool bFetch4 )\n""{\n""	float2 vPoissonOffset[8] = { float2(  0.3475f,  0.0042f ),\n""								 float2(  0.8806f,  0.3430f ),\n""								 float2( -0.0041f, -0.6197f ),\n""								 float2(  0.0472f,  0.4964f ),\n""								 float2( -0.3730f,  0.0874f ),\n""								 float2( -0.9217f, -0.3177f ),\n""								 float2( -0.6289f,  0.7388f ),\n""								 float2(  0.5744f, -0.7741f ) };\n""\n""	float flScaleOverMapSize = vShadowTweaks.x * 2;		// Tweak parameters to shader\n""	float2 vNoiseOffset = vShadowTweaks.zw;\n""	float4 vLightDepths = 0, accum = 0.0f;\n""	float2 rotOffset = 0;\n""\n""	float2 shadowMapCenter = vProjCoords.xy;			// Center of shadow filter\n""	float objDepth = min( vProjCoords.z, 0.99999 );		// Object depth in shadow space\n""\n""	// 2D Rotation Matrix setup\n""	float3 RMatTop = 0, RMatBottom = 0;\n""#if defined(SHADER_MODEL_PS_2_0) || defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0)\n""	RMatTop.xy = tex2D( RandomRotationSampler, cFlashlightScreenScale.xy * (vScreenPos * 0.5 + 0.5) + vNoiseOffset) * 2.0 - 1.0;\n""	RMatBottom.xy = float2(-1.0, 1.0) * RMatTop.yx;	// 2x2 rotation matrix in 4-tuple\n""#endif\n""\n""	RMatTop *= flScaleOverMapSize;				// Scale up kernel while accounting for texture resolution\n""	RMatBottom *= flScaleOverMapSize;\n""\n""	RMatTop.z = shadowMapCenter.x;				// To be added in d2adds generated below\n""	RMatBottom.z = shadowMapCenter.y;\n""	\n""	float fResult = 0.0f;\n""\n""	if ( bNvidiaHardwarePCF )\n""	{\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[0].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[0].xy) + RMatBottom.z;\n""		vLightDepths.x += tex2Dproj( DepthSampler, float4(rotOffset, objDepth, 1) ).x;\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[1].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[1].xy) + RMatBottom.z;\n""		vLightDepths.y += tex2Dproj( DepthSampler, float4(rotOffset, objDepth, 1) ).x;\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[2].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[2].xy) + RMatBottom.z;\n""		vLightDepths.z += tex2Dproj( DepthSampler, float4(rotOffset, objDepth, 1) ).x;\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[3].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[3].xy) + RMatBottom.z;\n""		vLightDepths.w += tex2Dproj( DepthSampler, float4(rotOffset, objDepth, 1) ).x;\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[4].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[4].xy) + RMatBottom.z;\n""		vLightDepths.x += tex2Dproj( DepthSampler, float4(rotOffset, objDepth, 1) ).x;\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[5].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[5].xy) + RMatBottom.z;\n""		vLightDepths.y += tex2Dproj( DepthSampler, float4(rotOffset, objDepth, 1) ).x;\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[6].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[6].xy) + RMatBottom.z;\n""		vLightDepths.z += tex2Dproj( DepthSampler, float4(rotOffset, objDepth, 1) ).x;\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[7].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[7].xy) + RMatBottom.z;\n""		vLightDepths.w += tex2Dproj( DepthSampler, float4(rotOffset, objDepth, 1) ).x;\n""\n""		fResult = dot( vLightDepths, float4( 0.25, 0.25, 0.25, 0.25) );\n""	}\n""	else if ( bFetch4 )\n""	{\n""/*\n""\n""TODO: Fix this contact hardening stuff\n""\n""		float flNumCloserSamples = 1;\n""		float flAccumulatedCloserSamples = objDepth;\n""		float4 vBlockerDepths;\n""\n""		// First, search for blockers\n""		for( int j=0; j<8; j++ )\n""		{\n""			rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[j].xy) + RMatTop.z;\n""			rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[j].xy) + RMatBottom.z;\n""			vBlockerDepths = tex2D( DepthSampler, rotOffset.xy );\n""\n""			// Which samples are closer than the pixel we're rendering?\n""			float4 vCloserSamples = (vBlockerDepths < objDepth.xxxx );				// Binary comparison results\n""			flNumCloserSamples += dot( vCloserSamples, float4(1, 1, 1, 1) );		// How many samples are closer than receiver?\n""			flAccumulatedCloserSamples += dot (vCloserSamples, vBlockerDepths );	// Total depths from samples closer than receiver\n""		}\n""\n""		float flBlockerDepth = flAccumulatedCloserSamples / flNumCloserSamples;\n""		float flContactHardeningScale = (objDepth - flBlockerDepth) / flBlockerDepth;\n""\n""		// Scale the kernel\n""		RMatTop.xy    *= flContactHardeningScale;\n""		RMatBottom.xy *= flContactHardeningScale;\n""*/\n""\n""		for( int i=0; i<8; i++ )\n""		{\n""			rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[i].xy) + RMatTop.z;\n""			rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[i].xy) + RMatBottom.z;\n""			vLightDepths = tex2D( DepthSampler, rotOffset.xy );\n""			accum += (vLightDepths > objDepth.xxxx);\n""		}\n""\n""		fResult = dot( accum, float4( 1.0f/32.0f, 1.0f/32.0f, 1.0f/32.0f, 1.0f/32.0f) );\n""	}\n""	else	// ATI vanilla hardware shadow mapping\n""	{\n""		for( int i=0; i<2; i++ )\n""		{\n""			rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[4*i+0].xy) + RMatTop.z;\n""			rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[4*i+0].xy) + RMatBottom.z;\n""			vLightDepths.x = tex2D( DepthSampler, rotOffset.xy ).x;\n""\n""			rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[4*i+1].xy) + RMatTop.z;\n""			rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[4*i+1].xy) + RMatBottom.z;\n""			vLightDepths.y = tex2D( DepthSampler, rotOffset.xy ).x;\n""\n""			rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[4*i+2].xy) + RMatTop.z;\n""			rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[4*i+2].xy) + RMatBottom.z;\n""			vLightDepths.z = tex2D( DepthSampler, rotOffset.xy ).x;\n""\n""			rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[4*i+3].xy) + RMatTop.z;\n""			rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[4*i+3].xy) + RMatBottom.z;\n""			vLightDepths.w = tex2D( DepthSampler, rotOffset.xy ).x;\n""\n""			accum += (vLightDepths > objDepth.xxxx);\n""		}\n""\n""		fResult = dot( accum, float4( 0.125, 0.125, 0.125, 0.125) );\n""	}\n""\n""	return fResult;\n""}\n""\n""#if defined( _X360 )\n""\n""// Poisson disc, randomly rotated at different UVs\n""float DoShadow360Simple( sampler DepthSampler, const float3 vProjCoords )\n""{\n""	float fLOD;\n""	float2 shadowMapCenter = vProjCoords.xy;			// Center of shadow filter\n""	float objDepth = min( vProjCoords.z, 0.99999 );		// Object depth in shadow space\n""\n""#if defined( REVERSE_DEPTH_ON_X360 )\n""	objDepth = 1.0f - objDepth;\n""#endif	\n""\n""	float4 vSampledDepths, vWeights;\n""\n""	asm {\n""		getCompTexLOD2D fLOD.x, shadowMapCenter.xy, DepthSampler, AnisoFilter=max16to1\n""			setTexLOD fLOD.x\n""\n""			tfetch2D vSampledDepths.x___, shadowMapCenter, DepthSampler, OffsetX = -0.5, OffsetY = -0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepths._x__, shadowMapCenter, DepthSampler, OffsetX =  0.5, OffsetY = -0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepths.__x_, shadowMapCenter, DepthSampler, OffsetX = -0.5, OffsetY =  0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepths.___x, shadowMapCenter, DepthSampler, OffsetX =  0.5, OffsetY =  0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""\n""			getWeights2D vWeights, shadowMapCenter.xy, DepthSampler, MagFilter=linear, MinFilter=linear, UseComputedLOD=false, UseRegisterLOD=true\n""	};\n""\n""	vWeights = float4( (1-vWeights.x)*(1-vWeights.y), vWeights.x*(1-vWeights.y), (1-vWeights.x)*vWeights.y, vWeights.x*vWeights.y );\n""\n""#if defined( REVERSE_DEPTH_ON_X360 )\n""	float4 vCompare = (vSampledDepths < objDepth.xxxx);\n""#else\n""	float4 vCompare = (vSampledDepths > objDepth.xxxx);\n""#endif\n""\n""	return dot( vCompare, vWeights );\n""}\n""\n""\n""float Do360PCFFetch( sampler DepthSampler, float2 tc, float objDepth )\n""{\n""	float fLOD;\n""	float4 vSampledDepths, vWeights;\n""\n""	asm {\n""			getCompTexLOD2D fLOD.x, tc.xy, DepthSampler, AnisoFilter=max16to1\n""			setTexLOD fLOD.x\n""\n""			tfetch2D vSampledDepths.x___, tc, DepthSampler, OffsetX = -0.5, OffsetY = -0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepths._x__, tc, DepthSampler, OffsetX =  0.5, OffsetY = -0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepths.__x_, tc, DepthSampler, OffsetX = -0.5, OffsetY =  0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepths.___x, tc, DepthSampler, OffsetX =  0.5, OffsetY =  0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""\n""			getWeights2D vWeights, tc.xy, DepthSampler, MagFilter=linear, MinFilter=linear, UseComputedLOD=false, UseRegisterLOD=true\n""	};\n""\n""	vWeights = float4( (1-vWeights.x)*(1-vWeights.y), vWeights.x*(1-vWeights.y), (1-vWeights.x)*vWeights.y, vWeights.x*vWeights.y );\n""\n""#if defined( REVERSE_DEPTH_ON_X360 )\n""	float4 vCompare = (vSampledDepths < objDepth.xxxx);\n""#else\n""	float4 vCompare = (vSampledDepths > objDepth.xxxx);\n""#endif\n""\n""	return dot( vCompare, vWeights );\n""}\n""\n""\n""\n""float Do360NearestFetch( sampler DepthSampler, float2 tc, float objDepth )\n""{\n""	float fLOD;\n""	float4 vSampledDepth;\n""\n""	asm {\n""		getCompTexLOD2D fLOD.x, tc.xy, DepthSampler, AnisoFilter=max16to1\n""		setTexLOD fLOD.x\n""\n""		tfetch2D vSampledDepth.x___, tc, DepthSampler, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""	};\n""\n""#if defined( REVERSE_DEPTH_ON_X360 )\n""	return (vSampledDepth.x < objDepth.x);\n""#else\n""	return (vSampledDepth.x > objDepth.x);\n""#endif\n""\n""}\n""\n""\n""float AmountShadowed_8Tap_360( sampler DepthSampler, float2 tc, float objDepth )\n""{\n""	float fLOD;\n""	float4 vSampledDepthsA, vSampledDepthsB;\n""\n""	// Optimal 8 rooks pattern to get an idea about whether we're at a penumbra or not\n""	// From [Kallio07] \"Scanline Edge-Flag Algorithm for Antialiasing\" \n""	//\n""	//        +---+---+---+---+---+---+---+---+\n""	//        |   |   |   |   |   | o |   |   |\n""	//        +---+---+---+---+---+---+---+---+\n""	//        | o |   |   |   |   |   |   |   |\n""	//        +---+---+---+---+---+---+---+---+\n""	//        |   |   |   | o |   |   |   |   |\n""	//        +---+---+---+---+---+---+---+---+\n""	//        |   |   |   |   |   |   | o |   |\n""	//        +---+---+---+---+---+---+---+---+\n""	//        |   | o |   |   |   |   |   |   |\n""	//        +---+---+---+---+---+---+---+---+\n""	//        |   |   |   |   | o |   |   |   |\n""	//        +---+---+---+---+---+---+---+---+\n""	//        |   |   |   |   |   |   |   | o |\n""	//        +---+---+---+---+---+---+---+---+\n""	//        |   |   | o |   |   |   |   |   |\n""	//        +---+---+---+---+---+---+---+---+\n""	//\n""	asm {\n""			getCompTexLOD2D fLOD.x, tc.xy, DepthSampler, AnisoFilter=max16to1\n""			setTexLOD fLOD.x\n""\n""			tfetch2D vSampledDepthsA.x___, tc, DepthSampler, OffsetX = -2.0, OffsetY = -1.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepthsA._x__, tc, DepthSampler, OffsetX = -1.5, OffsetY =  0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepthsA.__x_, tc, DepthSampler, OffsetX = -1.0, OffsetY =  2.0, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepthsA.___x, tc, DepthSampler, OffsetX = -0.5, OffsetY = -1.0, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""\n""			tfetch2D vSampledDepthsB.x___, tc, DepthSampler, OffsetX =  0.5, OffsetY =  1.0, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepthsB._x__, tc, DepthSampler, OffsetX =  1.0, OffsetY = -2.0, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepthsB.__x_, tc, DepthSampler, OffsetX =  1.5, OffsetY = -0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepthsB.___x, tc, DepthSampler, OffsetX =  2.0, OffsetY =  1.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""	};\n""\n""#if defined( REVERSE_DEPTH_ON_X360 )\n""	float4 vCompareA = (vSampledDepthsA < objDepth.xxxx);\n""	float4 vCompareB = (vSampledDepthsB < objDepth.xxxx);\n""#else\n""	float4 vCompareA = (vSampledDepthsA > objDepth.xxxx);\n""	float4 vCompareB = (vSampledDepthsB > objDepth.xxxx);\n""#endif\n""\n""	return dot( vCompareA, float4(0.125,0.125,0.125,0.125) ) + dot( vCompareB, float4(0.125,0.125,0.125,0.125) );\n""}\n""\n""\n""float AmountShadowed_4Tap_360( sampler DepthSampler, float2 tc, float objDepth )\n""{\n""	float fLOD;\n""	float4 vSampledDepths;\n""\n""	// Rotated grid pattern to get an idea about whether we're at a penumbra or not\n""	asm {\n""		getCompTexLOD2D fLOD.x, tc.xy, DepthSampler, AnisoFilter=max16to1\n""			setTexLOD fLOD.x\n""\n""			tfetch2D vSampledDepths.x___, tc, DepthSampler, OffsetX = -1.0, OffsetY =  0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepths._x__, tc, DepthSampler, OffsetX = -0.5, OffsetY = -1.0, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepths.__x_, tc, DepthSampler, OffsetX =  0.5, OffsetY =  1.0, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""			tfetch2D vSampledDepths.___x, tc, DepthSampler, OffsetX =  1.0, OffsetY = -0.5, UseComputedLOD=false, UseRegisterLOD=true, MagFilter = point, MinFilter = point\n""	};\n""\n""#if defined( REVERSE_DEPTH_ON_X360 )\n""	float4 vCompare = (vSampledDepths < objDepth.xxxx);\n""#else\n""	float4 vCompare = (vSampledDepths > objDepth.xxxx);\n""#endif\n""\n""	return dot( vCompare, float4(0.25,0.25,0.25,0.25) );\n""}\n""\n""// Poisson disc, randomly rotated at different UVs\n""float DoShadowPoisson360( sampler DepthSampler, sampler RandomRotationSampler, const float3 vProjCoords, const float2 vScreenPos, const float4 vShadowTweaks )\n""{\n""	float2 vPoissonOffset[8] = { float2(  0.3475f,  0.0042f ), float2(  0.8806f,  0.3430f ),\n""								 float2( -0.0041f, -0.6197f ), float2(  0.0472f,  0.4964f ),\n""								 float2( -0.3730f,  0.0874f ), float2( -0.9217f, -0.3177f ),\n""								 float2( -0.6289f,  0.7388f ), float2(  0.5744f, -0.7741f ) };\n""\n""	float2 shadowMapCenter = vProjCoords.xy;		// Center of shadow filter\n""	float objDepth = min( vProjCoords.z, 0.99999 );	// Object depth in shadow space\n""\n""#if defined( REVERSE_DEPTH_ON_X360 )\n""	objDepth = 1.0f - objDepth;\n""#endif\n""\n""	float fAmountShadowed = AmountShadowed_4Tap_360( DepthSampler, shadowMapCenter, objDepth );\n""\n""	if ( fAmountShadowed >= 1.0f )			// Fully in light\n""	{\n""		return 1.0f;\n""	}\n""	else	// Do the expensive filtering since we're at least partially shadowed\n""	{\n""		float flScaleOverMapSize = 1.7f / 512.0f;		// Tweak parameters to shader\n""\n""		// 2D Rotation Matrix setup\n""		float3 RMatTop = 0, RMatBottom = 0;\n""#if defined(SHADER_MODEL_PS_2_0) || defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0)\n""		RMatTop.xy = tex2D( RandomRotationSampler, cFlashlightScreenScale.xy * (vScreenPos * 0.5 + 0.5)) * 2.0 - 1.0;\n""		RMatBottom.xy = float2(-1.0, 1.0) * RMatTop.yx;	// 2x2 rotation matrix in 4-tuple\n""#endif\n""\n""		RMatTop *= flScaleOverMapSize;					// Scale up kernel while accounting for texture resolution\n""		RMatBottom *= flScaleOverMapSize;\n""		RMatTop.z = shadowMapCenter.x;					// To be added in d2adds generated below\n""		RMatBottom.z = shadowMapCenter.y;\n""		float2 rotOffset = float2(0,0);\n""		float4 vAccum = 0;\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[0].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[0].xy) + RMatBottom.z;\n""		vAccum.x  = Do360NearestFetch( DepthSampler, rotOffset, objDepth );\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[1].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[1].xy) + RMatBottom.z;\n""		vAccum.y  = Do360NearestFetch( DepthSampler, rotOffset, objDepth );\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[2].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[2].xy) + RMatBottom.z;\n""		vAccum.z  = Do360NearestFetch( DepthSampler, rotOffset, objDepth );\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[3].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[3].xy) + RMatBottom.z;\n""		vAccum.w  = Do360NearestFetch( DepthSampler, rotOffset, objDepth );\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[4].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[4].xy) + RMatBottom.z;\n""		vAccum.x += Do360NearestFetch( DepthSampler, rotOffset, objDepth );\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[5].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[5].xy) + RMatBottom.z;\n""		vAccum.y += Do360NearestFetch( DepthSampler, rotOffset, objDepth );\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[6].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[6].xy) + RMatBottom.z;\n""		vAccum.z += Do360NearestFetch( DepthSampler, rotOffset, objDepth );\n""\n""		rotOffset.x = dot (RMatTop.xy,    vPoissonOffset[7].xy) + RMatTop.z;\n""		rotOffset.y = dot (RMatBottom.xy, vPoissonOffset[7].xy) + RMatBottom.z;\n""		vAccum.w += Do360NearestFetch( DepthSampler, rotOffset, objDepth );\n""\n""		return dot( vAccum, float4( 0.25, 0.25, 0.25, 0.25) );\n""	}\n""}\n""\n""#endif // _X360\n""\n""\n""float DoFlashlightShadow( sampler DepthSampler, sampler RandomRotationSampler, float3 vProjCoords, float2 vScreenPos, int nShadowLevel, float4 vShadowTweaks, bool bAllowHighQuality )\n""{\n""	float flShadow = 1.0f;\n""\n""#if !defined( _X360 ) //PC\n""	if( nShadowLevel == NVIDIA_PCF_POISSON )\n""		flShadow = DoShadowPoisson16Sample( DepthSampler, RandomRotationSampler, vProjCoords, vScreenPos, vShadowTweaks, true, false );\n""	else if( nShadowLevel == ATI_NOPCF )\n""		flShadow = DoShadowPoisson16Sample( DepthSampler, RandomRotationSampler, vProjCoords, vScreenPos, vShadowTweaks, false, false );\n""	else if( nShadowLevel == ATI_NO_PCF_FETCH4 )\n""		flShadow = DoShadowPoisson16Sample( DepthSampler, RandomRotationSampler, vProjCoords, vScreenPos, vShadowTweaks, false, true );\n""\n""	return flShadow;\n""#else\n""\n""	// Compile-time switch for shaders which allow high quality modes on 360\n""	if ( bAllowHighQuality )\n""	{\n""		// Static control flow switch for shadow quality.  Some non-interactive sequences use the high quality path\n""		if ( g_bHighQualityShadows )\n""		{\n""			flShadow = DoShadowPoisson360( DepthSampler, RandomRotationSampler, vProjCoords, vScreenPos, vShadowTweaks );\n""		}\n""		else\n""		{\n""			flShadow = DoShadow360Simple( DepthSampler, vProjCoords );\n""		}\n""	}\n""	else\n""	{\n""		flShadow = DoShadow360Simple( DepthSampler, vProjCoords );\n""	}\n""\n""	return flShadow;\n""\n""#endif\n""}\n""\n""float3 SpecularLight( const float3 vWorldNormal, const float3 vLightDir, const float fSpecularExponent,\n""					  const float3 vEyeDir, const bool bDoSpecularWarp, in sampler specularWarpSampler, float fFresnel )\n""{\n""	float3 result = float3(0.0f, 0.0f, 0.0f);\n""\n""	//float3 vReflect = reflect( -vEyeDir, vWorldNormal );\n""	float3 vReflect = 2 * vWorldNormal * dot( vWorldNormal , vEyeDir ) - vEyeDir; // Reflect view through normal\n""	float3 vSpecular = saturate(dot( vReflect, vLightDir ));		// L.R	(use half-angle instead?)\n""	vSpecular = pow( vSpecular.x, fSpecularExponent );				// Raise to specular power\n""\n""	// Optionally warp as function of scalar specular and fresnel\n""	if ( bDoSpecularWarp )\n""		vSpecular *= tex2D( specularWarpSampler, float2(vSpecular.x, fFresnel) ); // Sample at { (L.R)^k, fresnel }\n""\n""	return vSpecular;\n""}\n""\n""void DoSpecularFlashlight( float3 flashlightPos, float3 worldPos, float4 flashlightSpacePosition, float3 worldNormal,  \n""					float3 attenuationFactors, float farZ, sampler FlashlightSampler, sampler FlashlightDepthSampler, sampler RandomRotationSampler,\n""					int nShadowLevel, bool bDoShadows, bool bAllowHighQuality, const float2 vScreenPos, const float fSpecularExponent, const float3 vEyeDir,\n""					const bool bDoSpecularWarp, sampler specularWarpSampler, float fFresnel, float4 vShadowTweaks,\n""\n""					// Outputs of this shader...separate shadowed diffuse and specular from the flashlight\n""					out float3 diffuseLighting, out float3 specularLighting )\n""{\n""	float3 vProjCoords = flashlightSpacePosition.xyz / flashlightSpacePosition.w;\n""	float3 flashlightColor = float3(1,1,1);\n""\n""#if ( defined( _X360 ) )\n""\n""	float3 ltz = vProjCoords.xyz < float3( 0.0f, 0.0f, 0.0f );\n""	float3 gto = vProjCoords.xyz > float3( 1.0f, 1.0f, 1.0f );\n""\n""	[branch]\n""	if ( dot(ltz + gto, float3(1,1,1)) > 0 )\n""	{\n""		clip(-1);\n""		diffuseLighting = specularLighting = float3(0,0,0);\n""		return;\n""	}\n""	else\n""	{\n""		flashlightColor = tex2D( FlashlightSampler, vProjCoords );\n""\n""		[branch]\n""		if ( dot(flashlightColor.xyz, float3(1,1,1)) <= 0 )\n""		{\n""			clip(-1);\n""			diffuseLighting = specularLighting = float3(0,0,0);\n""			return;\n""		}\n""	}\n""#else\n""	flashlightColor = tex2D( FlashlightSampler, vProjCoords );\n""#endif\n""\n""\n""#if defined(SHADER_MODEL_PS_2_0) || defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0)\n""	flashlightColor *= cFlashlightColor.xyz;						// Flashlight color\n""#endif\n""\n""	float3 delta = flashlightPos - worldPos;\n""	float3 L = normalize( delta );\n""	float distSquared = dot( delta, delta );\n""	float dist = sqrt( distSquared );\n""\n""	float endFalloffFactor = RemapValClamped( dist, farZ, 0.6f * farZ, 0.0f, 1.0f );\n""\n""	// Attenuation for light and to fade out shadow over distance\n""	float fAtten = saturate( dot( attenuationFactors, float3( 1.0f, 1.0f/dist, 1.0f/distSquared ) ) );\n""\n""	// Shadowing and coloring terms\n""#if (defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0))\n""	if ( bDoShadows )\n""	{\n""		float flShadow = DoFlashlightShadow( FlashlightDepthSampler, RandomRotationSampler, vProjCoords, vScreenPos, nShadowLevel, vShadowTweaks, bAllowHighQuality );\n""		float flAttenuated = lerp( flShadow, 1.0f, vShadowTweaks.y );	// Blend between fully attenuated and not attenuated\n""		flShadow = saturate( lerp( flAttenuated, flShadow, fAtten ) );	// Blend between shadow and above, according to light attenuation\n""		flashlightColor *= flShadow;									// Shadow term\n""	}\n""#endif\n""\n""	diffuseLighting = fAtten;\n""#if defined(SHADER_MODEL_PS_2_0) || defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0)\n""		diffuseLighting *= saturate( dot( L.xyz, worldNormal.xyz ) + flFlashlightNoLambertValue ); // Lambertian term\n""#else\n""		diffuseLighting *= saturate( dot( L.xyz, worldNormal.xyz ) ); // Lambertian (not Half-Lambert) term\n""#endif\n""	diffuseLighting *= flashlightColor;\n""	diffuseLighting *= endFalloffFactor;\n""\n""	// Specular term (masked by diffuse)\n""	specularLighting = diffuseLighting * SpecularLight ( worldNormal, L, fSpecularExponent, vEyeDir, bDoSpecularWarp, specularWarpSampler, fFresnel );\n""}\n""\n""// Diffuse only version\n""float3 DoFlashlight( float3 flashlightPos, float3 worldPos, float4 flashlightSpacePosition, float3 worldNormal, \n""					float3 attenuationFactors, float farZ, sampler FlashlightSampler, sampler FlashlightDepthSampler,\n""					sampler RandomRotationSampler, int nShadowLevel, bool bDoShadows, bool bAllowHighQuality,\n""					const float2 vScreenPos, bool bClip, float4 vShadowTweaks = float4(3/1024.0f, 0.0005f, 0.0f, 0.0f), bool bHasNormal = true )\n""{\n""	float3 vProjCoords = flashlightSpacePosition.xyz / flashlightSpacePosition.w;\n""	float3 flashlightColor = float3(1,1,1);\n""\n""#if ( defined( _X360 ) )\n""\n""	float3 ltz = vProjCoords.xyz < float3( 0.0f, 0.0f, 0.0f );\n""	float3 gto = vProjCoords.xyz > float3( 1.0f, 1.0f, 1.0f );\n""\n""	[branch]\n""	if ( dot(ltz + gto, float3(1,1,1)) > 0 )\n""	{\n""		if ( bClip )\n""		{\n""			clip(-1);\n""		}\n""		return float3(0,0,0);\n""	}\n""	else\n""	{\n""		flashlightColor = tex2D( FlashlightSampler, vProjCoords );\n""\n""		[branch]\n""		if ( dot(flashlightColor.xyz, float3(1,1,1)) <= 0 )\n""		{\n""			if ( bClip )\n""			{\n""				clip(-1);\n""			}\n""			return float3(0,0,0);\n""		}\n""	}\n""#else\n""	flashlightColor = tex2D( FlashlightSampler, vProjCoords );\n""#endif\n""\n""#if defined(SHADER_MODEL_PS_2_0) || defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0)\n""	flashlightColor *= cFlashlightColor.xyz;						// Flashlight color\n""#endif\n""\n""	float3 delta = flashlightPos - worldPos;\n""	float3 L = normalize( delta );\n""	float distSquared = dot( delta, delta );\n""	float dist = sqrt( distSquared );\n""\n""	float endFalloffFactor = RemapValClamped( dist, farZ, 0.6f * farZ, 0.0f, 1.0f );\n""\n""	// Attenuation for light and to fade out shadow over distance\n""	float fAtten = saturate( dot( attenuationFactors, float3( 1.0f, 1.0f/dist, 1.0f/distSquared ) ) );\n""\n""	// Shadowing and coloring terms\n""#if (defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0))\n""	if ( bDoShadows )\n""	{\n""		float flShadow = DoFlashlightShadow( FlashlightDepthSampler, RandomRotationSampler, vProjCoords, vScreenPos, nShadowLevel, vShadowTweaks, bAllowHighQuality );\n""		float flAttenuated = lerp( flShadow, 1.0f, vShadowTweaks.y );	// Blend between fully attenuated and not attenuated\n""		flShadow = saturate( lerp( flAttenuated, flShadow, fAtten ) );	// Blend between shadow and above, according to light attenuation\n""		flashlightColor *= flShadow;									// Shadow term\n""	}\n""#endif\n""\n""	float3 diffuseLighting = fAtten;\n""\n""	float flLDotWorldNormal;\n""	if ( bHasNormal )\n""	{\n""		flLDotWorldNormal = dot( L.xyz, worldNormal.xyz );\n""	}\n""	else\n""	{\n""		flLDotWorldNormal = 1.0f;\n""	}\n""\n""#if defined(SHADER_MODEL_PS_2_0) || defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0)\n""	diffuseLighting *= saturate( flLDotWorldNormal + flFlashlightNoLambertValue ); // Lambertian term\n""#else\n""	diffuseLighting *= saturate( flLDotWorldNormal ); // Lambertian (not Half-Lambert) term\n""#endif\n""\n""	diffuseLighting *= flashlightColor;\n""	diffuseLighting *= endFalloffFactor;\n""\n""	return diffuseLighting;\n""}\n""\n""#endif //#ifndef COMMON_FLASHLIGHT_FXC_H_\n""\n";