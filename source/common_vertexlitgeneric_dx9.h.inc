const char common_vertexlitgeneric_dx9_h[] = "//========= Copyright Valve Corporation, All rights reserved. ============//\n""#ifndef COMMON_VERTEXLITGENERIC_DX9_H_\n""#define COMMON_VERTEXLITGENERIC_DX9_H_\n""\n""#include \"common_ps_fxc.h\"\n""\n""//  We store four light colors and positions in an\n""//  array of three of these structures like so:\n""//\n""//       x		y		z      w\n""//    +------+------+------+------+\n""//    |       L0.rgb       |      |\n""//    +------+------+------+      |\n""//    |       L0.pos       |  L3  |\n""//    +------+------+------+  rgb |\n""//    |       L1.rgb       |      |\n""//    +------+------+------+------+\n""//    |       L1.pos       |      |\n""//    +------+------+------+      |\n""//    |       L2.rgb       |  L3  |\n""//    +------+------+------+  pos |\n""//    |       L2.pos       |      |\n""//    +------+------+------+------+\n""//\n""struct PixelShaderLightInfo\n""{\n""	float4 color;\n""	float4 pos;\n""};\n""\n""#define cOverbright 2.0f\n""#define cOOOverbright 0.5f\n""\n""#define LIGHTTYPE_NONE				0\n""#define LIGHTTYPE_SPOT				1\n""#define LIGHTTYPE_POINT				2\n""#define LIGHTTYPE_DIRECTIONAL		3\n""\n""// Better suited to Pixel shader models, 11 instructions in pixel shader\n""// ... actually, now only 9: mul, cmp, cmp, mul, mad, mad, mad, mad, mad\n""float3 PixelShaderAmbientLight( const float3 worldNormal, const float3 cAmbientCube[6] )\n""{\n""	float3 linearColor, nSquared = worldNormal * worldNormal;\n""	float3 isNegative = ( worldNormal >= 0.0 ) ? 0 : nSquared;\n""	float3 isPositive = ( worldNormal >= 0.0 ) ? nSquared : 0;\n""	linearColor = isPositive.x * cAmbientCube[0] + isNegative.x * cAmbientCube[1] +\n""				  isPositive.y * cAmbientCube[2] + isNegative.y * cAmbientCube[3] +\n""				  isPositive.z * cAmbientCube[4] + isNegative.z * cAmbientCube[5];\n""	return linearColor;\n""}\n""\n""// Better suited to Vertex shader models\n""// Six VS instructions due to use of constant indexing (slt, mova, mul, mul, mad, mad)\n""float3 VertexShaderAmbientLight( const float3 worldNormal, const float3 cAmbientCube[6] )\n""{\n""	float3 nSquared = worldNormal * worldNormal;\n""	int3 isNegative = ( worldNormal < 0.0 );\n""	float3 linearColor;\n""	linearColor = nSquared.x * cAmbientCube[isNegative.x] +\n""	              nSquared.y * cAmbientCube[isNegative.y+2] +\n""	              nSquared.z * cAmbientCube[isNegative.z+4];\n""	return linearColor;\n""}\n""\n""float3 AmbientLight( const float3 worldNormal, const float3 cAmbientCube[6] )\n""{\n""	// Vertex shader cases\n""#ifdef SHADER_MODEL_VS_1_0\n""	return VertexShaderAmbientLight( worldNormal, cAmbientCube );\n""#elif SHADER_MODEL_VS_1_1\n""	return VertexShaderAmbientLight( worldNormal, cAmbientCube );\n""#elif SHADER_MODEL_VS_2_0\n""	return VertexShaderAmbientLight( worldNormal, cAmbientCube );\n""#elif SHADER_MODEL_VS_3_0\n""	return VertexShaderAmbientLight( worldNormal, cAmbientCube );\n""#else\n""	// Pixel shader case\n""	return PixelShaderAmbientLight( worldNormal, cAmbientCube );\n""#endif\n""}\n""\n""//-----------------------------------------------------------------------------\n""// Purpose: Compute scalar diffuse term with various optional tweaks such as\n""//          Half Lambert and ambient occlusion\n""//-----------------------------------------------------------------------------\n""float3 DiffuseTerm(const bool bHalfLambert, const float3 worldNormal, const float3 lightDir,\n""				   const bool bDoAmbientOcclusion, const float fAmbientOcclusion,\n""				   const bool bDoLightingWarp, in sampler lightWarpSampler )\n""{\n""	float fResult;\n""\n""	float NDotL = dot( worldNormal, lightDir );				// Unsaturated dot (-1 to 1 range)\n""\n""	if ( bHalfLambert )\n""	{\n""		fResult = saturate(NDotL * 0.5 + 0.5);				// Scale and bias to 0 to 1 range\n""\n""		if ( !bDoLightingWarp )\n""		{\n""			fResult *= fResult;								// Square\n""		}\n""	}\n""	else\n""	{\n""		fResult = saturate( NDotL );						// Saturate pure Lambertian term\n""	}\n""\n""	if ( bDoAmbientOcclusion )\n""	{\n""		// Raise to higher powers for darker AO values\n""//		float fAOPower = lerp( 4.0f, 1.0f, fAmbientOcclusion );\n""//		result *= pow( NDotL * 0.5 + 0.5, fAOPower );\n""		fResult *= fAmbientOcclusion;\n""	}\n""\n""	float3 fOut = float3( fResult, fResult, fResult );\n""	if ( bDoLightingWarp )\n""	{\n""		fOut = 2.0f * tex1D( lightWarpSampler, fResult );\n""	}\n""\n""	return fOut;\n""}\n""\n""float3 PixelShaderDoGeneralDiffuseLight( const float fAtten, const float3 worldPos, const float3 worldNormal,\n""										 in sampler NormalizeSampler,\n""										 const float3 vPosition, const float3 vColor, const bool bHalfLambert,\n""										 const bool bDoAmbientOcclusion, const float fAmbientOcclusion,\n""										 const bool bDoLightingWarp, in sampler lightWarpSampler )\n""{\n""#if (defined(SHADER_MODEL_PS_2_B) || defined(SHADER_MODEL_PS_3_0))\n""	float3 lightDir = normalize( vPosition - worldPos );\n""#else\n""	float3 lightDir = NormalizeWithCubemap( NormalizeSampler, vPosition - worldPos );\n""#endif\n""	return vColor * fAtten * DiffuseTerm( bHalfLambert, worldNormal, lightDir, bDoAmbientOcclusion, fAmbientOcclusion, bDoLightingWarp, lightWarpSampler );\n""}\n""\n""float3 PixelShaderGetLightVector( const float3 worldPos, PixelShaderLightInfo cLightInfo[3], int nLightIndex )\n""{\n""	if ( nLightIndex == 3 )\n""	{\n""		// Unpack light 3 from w components...\n""		float3 vLight3Pos = float3( cLightInfo[1].pos.w, cLightInfo[2].color.w, cLightInfo[2].pos.w );\n""		return normalize( vLight3Pos - worldPos );\n""	}\n""	else\n""	{\n""		return normalize( cLightInfo[nLightIndex].pos - worldPos );\n""	}\n""}\n""\n""float3 PixelShaderGetLightColor( PixelShaderLightInfo cLightInfo[3], int nLightIndex )\n""{\n""	if ( nLightIndex == 3 )\n""	{\n""		// Unpack light 3 from w components...\n""		return float3( cLightInfo[0].color.w, cLightInfo[0].pos.w, cLightInfo[1].color.w );\n""	}\n""	else\n""	{\n""		return cLightInfo[nLightIndex].color.rgb;\n""	}\n""}\n""\n""\n""void SpecularAndRimTerms( const float3 vWorldNormal, const float3 vLightDir, const float fSpecularExponent,\n""						  const float3 vEyeDir, const bool bDoAmbientOcclusion, const float fAmbientOcclusion,\n""						  const bool bDoSpecularWarp, in sampler specularWarpSampler, const float fFresnel,\n""						  const float3 color, const bool bDoRimLighting, const float fRimExponent,\n""\n""						  // Outputs\n""						  out float3 specularLighting, out float3 rimLighting )\n""{\n""	rimLighting = float3(0.0f, 0.0f, 0.0f);\n""\n""	//float3 vReflect = reflect( -vEyeDir, vWorldNormal );				// Reflect view through normal\n""	float3 vReflect = 2 * vWorldNormal * dot( vWorldNormal , vEyeDir ) - vEyeDir; // Reflect view through normal\n""	float LdotR = saturate(dot( vReflect, vLightDir ));					// L.R	(use half-angle instead?)\n""	specularLighting = pow( LdotR, fSpecularExponent );					// Raise to specular exponent\n""\n""	// Optionally warp as function of scalar specular and fresnel\n""	if ( bDoSpecularWarp )\n""		specularLighting *= tex2D( specularWarpSampler, float2(specularLighting.x, fFresnel) ); // Sample at { (L.R)^k, fresnel }\n""\n""	specularLighting *= saturate(dot( vWorldNormal, vLightDir ));		// Mask with N.L\n""	specularLighting *= color;											// Modulate with light color\n""\n""	if ( bDoAmbientOcclusion )											// Optionally modulate with ambient occlusion\n""		specularLighting *= fAmbientOcclusion;\n""\n""	if ( bDoRimLighting )												// Optionally do rim lighting\n""	{\n""		rimLighting  = pow( LdotR, fRimExponent );						// Raise to rim exponent\n""		rimLighting *= saturate(dot( vWorldNormal, vLightDir ));		// Mask with N.L\n""		rimLighting *= color;											// Modulate with light color\n""	}\n""}\n""\n""// Traditional fresnel term approximation\n""float Fresnel( const float3 vNormal, const float3 vEyeDir )\n""{\n""	float fresnel = saturate( 1 - dot( vNormal, vEyeDir ) );			// 1-(N.V) for Fresnel term\n""	return fresnel * fresnel;											// Square for a more subtle look\n""}\n""\n""// Traditional fresnel term approximation which uses 4th power (square twice)\n""float Fresnel4( const float3 vNormal, const float3 vEyeDir )\n""{\n""	float fresnel = saturate( 1 - dot( vNormal, vEyeDir ) );			// 1-(N.V) for Fresnel term\n""	fresnel = fresnel * fresnel;										// Square\n""	return fresnel * fresnel;											// Square again for a more subtle look\n""}\n""\n""\n""//\n""// Custom Fresnel with low, mid and high parameters defining a piecewise continuous function\n""// with traditional fresnel (0 to 1 range) as input.  The 0 to 0.5 range blends between\n""// low and mid while the 0.5 to 1 range blends between mid and high\n""//\n""//    |\n""//    |    .  M . . . H\n""//    | . \n""//    L\n""//    |\n""//    +----------------\n""//    0               1\n""//\n""float Fresnel( const float3 vNormal, const float3 vEyeDir, float3 vRanges )\n""{\n""	//float result, f = Fresnel( vNormal, vEyeDir );			// Traditional Fresnel\n""	//if ( f > 0.5f )\n""	//	result = lerp( vRanges.y, vRanges.z, (2*f)-1 );		// Blend between mid and high values\n""	//else\n""	//	result = lerp( vRanges.x, vRanges.y, 2*f );			// Blend between low and mid values\n""\n""	// note: vRanges is now encoded as ((mid-min)*2, mid, (max-mid)*2) to optimize math\n""	float f = saturate( 1 - dot( vNormal, vEyeDir ) );\n""	f = f*f - 0.5;\n""	return vRanges.y + (f >= 0.0 ? vRanges.z : vRanges.x) * f;\n""}\n""\n""void PixelShaderDoSpecularLight( const float3 vWorldPos, const float3 vWorldNormal, const float fSpecularExponent, const float3 vEyeDir,\n""								 const float fAtten, const float3 vLightColor, const float3 vLightDir,\n""								 const bool bDoAmbientOcclusion, const float fAmbientOcclusion,\n""								 const bool bDoSpecularWarp, in sampler specularWarpSampler, float fFresnel,\n""								 const bool bDoRimLighting, const float fRimExponent,\n""\n""								 // Outputs\n""								 out float3 specularLighting, out float3 rimLighting )\n""{\n""	// Compute Specular and rim terms\n""	SpecularAndRimTerms( vWorldNormal, vLightDir, fSpecularExponent,\n""						 vEyeDir, bDoAmbientOcclusion, fAmbientOcclusion,\n""						 bDoSpecularWarp, specularWarpSampler, fFresnel, vLightColor * fAtten,\n""						 bDoRimLighting, fRimExponent, specularLighting, rimLighting );\n""}\n""\n""float3 PixelShaderDoLightingLinear( const float3 worldPos, const float3 worldNormal,\n""				   const float3 staticLightingColor, const bool bStaticLight,\n""				   const bool bAmbientLight, const float4 lightAtten, const float3 cAmbientCube[6],\n""				   in sampler NormalizeSampler, const int nNumLights, PixelShaderLightInfo cLightInfo[3],\n""				   const bool bHalfLambert, const bool bDoAmbientOcclusion, const float fAmbientOcclusion,\n""				   const bool bDoLightingWarp, in sampler lightWarpSampler )\n""{\n""	float3 linearColor = 0.0f;\n""\n""	if ( bStaticLight )\n""	{\n""		// The static lighting comes in in gamma space and has also been premultiplied by $cOOOverbright\n""		// need to get it into\n""		// linear space so that we can do adds.\n""		linearColor += GammaToLinear( staticLightingColor * cOverbright );\n""	}\n""\n""	if ( bAmbientLight )\n""	{\n""		float3 ambient = AmbientLight( worldNormal, cAmbientCube );\n""\n""		if ( bDoAmbientOcclusion )\n""			ambient *= fAmbientOcclusion * fAmbientOcclusion;	// Note squaring...\n""\n""		linearColor += ambient;\n""	}\n""\n""	if ( nNumLights > 0 )\n""	{\n""		linearColor += PixelShaderDoGeneralDiffuseLight( lightAtten.x, worldPos, worldNormal, NormalizeSampler,\n""														 cLightInfo[0].pos, cLightInfo[0].color, bHalfLambert,\n""														 bDoAmbientOcclusion, fAmbientOcclusion,\n""														 bDoLightingWarp, lightWarpSampler );\n""		if ( nNumLights > 1 )\n""		{\n""			linearColor += PixelShaderDoGeneralDiffuseLight( lightAtten.y, worldPos, worldNormal, NormalizeSampler,\n""															 cLightInfo[1].pos, cLightInfo[1].color, bHalfLambert,\n""															 bDoAmbientOcclusion, fAmbientOcclusion,\n""															 bDoLightingWarp, lightWarpSampler );\n""			if ( nNumLights > 2 )\n""			{\n""				linearColor += PixelShaderDoGeneralDiffuseLight( lightAtten.z, worldPos, worldNormal, NormalizeSampler,\n""																 cLightInfo[2].pos, cLightInfo[2].color, bHalfLambert,\n""																 bDoAmbientOcclusion, fAmbientOcclusion,\n""																 bDoLightingWarp, lightWarpSampler );\n""				if ( nNumLights > 3 )\n""				{\n""					// Unpack the 4th light's data from tight constant packing\n""					float3 vLight3Color = float3( cLightInfo[0].color.w, cLightInfo[0].pos.w, cLightInfo[1].color.w );\n""					float3 vLight3Pos = float3( cLightInfo[1].pos.w, cLightInfo[2].color.w, cLightInfo[2].pos.w );\n""					linearColor += PixelShaderDoGeneralDiffuseLight( lightAtten.w, worldPos, worldNormal, NormalizeSampler,\n""																	 vLight3Pos, vLight3Color, bHalfLambert,\n""																	 bDoAmbientOcclusion, fAmbientOcclusion,\n""																	 bDoLightingWarp, lightWarpSampler );\n""				}\n""			}\n""		}\n""	}\n""\n""	return linearColor;\n""}\n""\n""void PixelShaderDoSpecularLighting( const float3 worldPos, const float3 worldNormal, const float fSpecularExponent, const float3 vEyeDir,\n""									const float4 lightAtten, const int nNumLights, PixelShaderLightInfo cLightInfo[3],\n""									const bool bDoAmbientOcclusion, const float fAmbientOcclusion,\n""									const bool bDoSpecularWarp, in sampler specularWarpSampler, float fFresnel,\n""									const bool bDoRimLighting, const float fRimExponent,\n""\n""									// Outputs\n""									out float3 specularLighting, out float3 rimLighting )\n""{\n""	specularLighting = rimLighting = float3( 0.0f, 0.0f, 0.0f );\n""	float3 localSpecularTerm, localRimTerm;\n""\n""	if( nNumLights > 0 )\n""	{\n""		PixelShaderDoSpecularLight( worldPos, worldNormal, fSpecularExponent, vEyeDir,\n""									lightAtten.x, PixelShaderGetLightColor( cLightInfo, 0 ),\n""									PixelShaderGetLightVector( worldPos, cLightInfo, 0 ),\n""									bDoAmbientOcclusion, fAmbientOcclusion,\n""									bDoSpecularWarp, specularWarpSampler, fFresnel,\n""									bDoRimLighting, fRimExponent,\n""									localSpecularTerm, localRimTerm );\n""\n""		specularLighting += localSpecularTerm;		// Accumulate specular and rim terms\n""		rimLighting += localRimTerm;\n""	}\n""\n""	if( nNumLights > 1 )\n""	{\n""		PixelShaderDoSpecularLight( worldPos, worldNormal, fSpecularExponent, vEyeDir,\n""									lightAtten.y, PixelShaderGetLightColor( cLightInfo, 1 ),\n""									PixelShaderGetLightVector( worldPos, cLightInfo, 1 ),\n""									bDoAmbientOcclusion, fAmbientOcclusion,\n""									bDoSpecularWarp, specularWarpSampler, fFresnel,\n""									bDoRimLighting, fRimExponent,\n""									localSpecularTerm, localRimTerm );\n""\n""		specularLighting += localSpecularTerm;		// Accumulate specular and rim terms\n""		rimLighting += localRimTerm;\n""	}\n""\n""\n""	if( nNumLights > 2 )\n""	{\n""		PixelShaderDoSpecularLight( worldPos, worldNormal, fSpecularExponent, vEyeDir,\n""									lightAtten.z, PixelShaderGetLightColor( cLightInfo, 2 ),\n""									PixelShaderGetLightVector( worldPos, cLightInfo, 2 ),\n""									bDoAmbientOcclusion, fAmbientOcclusion,\n""									bDoSpecularWarp, specularWarpSampler, fFresnel,\n""									bDoRimLighting, fRimExponent,\n""									localSpecularTerm, localRimTerm );\n""\n""		specularLighting += localSpecularTerm;		// Accumulate specular and rim terms\n""		rimLighting += localRimTerm;\n""	}\n""\n""	if( nNumLights > 3 )\n""	{\n""		PixelShaderDoSpecularLight( worldPos, worldNormal, fSpecularExponent, vEyeDir,\n""									lightAtten.w, PixelShaderGetLightColor( cLightInfo, 3 ),\n""									PixelShaderGetLightVector( worldPos, cLightInfo, 3 ),\n""									bDoAmbientOcclusion, fAmbientOcclusion,\n""									bDoSpecularWarp, specularWarpSampler, fFresnel,\n""									bDoRimLighting, fRimExponent,\n""									localSpecularTerm, localRimTerm );\n""\n""		specularLighting += localSpecularTerm;		// Accumulate specular and rim terms\n""		rimLighting += localRimTerm;\n""	}\n""\n""}\n""\n""float3 PixelShaderDoRimLighting( const float3 worldNormal, const float3 vEyeDir, const float3 cAmbientCube[6], float fFresnel )\n""{\n""	float3 vReflect = reflect( -vEyeDir, worldNormal );			// Reflect view through normal\n""\n""	return fFresnel * PixelShaderAmbientLight( vEyeDir, cAmbientCube );\n""}\n""\n""// Called directly by newer shaders or through the following wrapper for older shaders\n""float3 PixelShaderDoLighting( const float3 worldPos, const float3 worldNormal,\n""				   const float3 staticLightingColor, const bool bStaticLight,\n""				   const bool bAmbientLight, const float4 lightAtten, const float3 cAmbientCube[6],\n""				   in sampler NormalizeSampler, const int nNumLights, PixelShaderLightInfo cLightInfo[3],\n""				   const bool bHalfLambert,\n""				   \n""				   // New optional/experimental parameters\n""				   const bool bDoAmbientOcclusion, const float fAmbientOcclusion,\n""				   const bool bDoLightingWarp, in sampler lightWarpSampler )\n""{\n""	float3 linearColor = PixelShaderDoLightingLinear( worldPos, worldNormal, staticLightingColor, \n""													  bStaticLight, bAmbientLight, lightAtten,\n""													  cAmbientCube, NormalizeSampler, nNumLights, cLightInfo, bHalfLambert,\n""													  bDoAmbientOcclusion, fAmbientOcclusion,\n""													  bDoLightingWarp, lightWarpSampler );\n""\n""		// go ahead and clamp to the linear space equivalent of overbright 2 so that we match\n""		// everything else.\n""//		linearColor = HuePreservingColorClamp( linearColor, pow( 2.0f, 2.2 ) );\n""\n""	return linearColor;\n""}\n""\n""#endif //#ifndef COMMON_VERTEXLITGENERIC_DX9_H_\n""\n";